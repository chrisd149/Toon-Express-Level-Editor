1592975687
3 3
9 libp3chan 4 8NZB 12 panda3d.core 
220
210 37 upcast_to_TypedWritableReferenceCount 0 12 430 48 AnimGroup::upcast_to_TypedWritableReferenceCount 0 1 11 52
upcast from AnimGroup to TypedWritableReferenceCount
84
TypedWritableReferenceCount *AnimGroup::upcast_to_TypedWritableReferenceCount(void);

211 21 downcast_to_AnimGroup 0 12 431 50 TypedWritableReferenceCount::downcast_to_AnimGroup 0 0 54
downcast from TypedWritableReferenceCount to AnimGroup
68
AnimGroup *TypedWritableReferenceCount::downcast_to_AnimGroup(void);

212 17 upcast_to_Namable 0 12 430 28 AnimGroup::upcast_to_Namable 0 1 12 32
upcast from AnimGroup to Namable
44
Namable *AnimGroup::upcast_to_Namable(void);

213 21 downcast_to_AnimGroup 0 12 432 30 Namable::downcast_to_AnimGroup 0 0 34
downcast from Namable to AnimGroup
48
AnimGroup *Namable::downcast_to_AnimGroup(void);

214 9 AnimGroup 0 4 430 20 AnimGroup::AnimGroup 0 2 1 2 607
// This is the normal AnimGroup constructor.

/**
 * The default constructor is protected: don't try to create an AnimGroup
 * without a parent.  To create an AnimChannel hierarchy, you must first
 * create an AnimBundle, and use that to create any subsequent children.
 */

/**
 * Creates a new AnimGroup, just like this one, without copying any children.
 * The new copy is added to the indicated parent.  Intended to be called by
 * make_copy() only.
 */

/**
 * Creates the AnimGroup, and adds it to the indicated parent.  The only way
 * to delete it subsequently is to delete the entire hierarchy.
 */
132
explicit AnimGroup::AnimGroup(AnimGroup *parent, std::string const &name);
inline AnimGroup::AnimGroup(AnimGroup const &) = default;

215 10 ~AnimGroup 0 6 430 21 AnimGroup::~AnimGroup 0 0 10
/**
 *
 */
36
virtual AnimGroup::~AnimGroup(void);

216 16 get_num_children 0 4 430 27 AnimGroup::get_num_children 0 1 3 58
/**
 * Returns the number of child nodes of the group.
 */
44
int AnimGroup::get_num_children(void) const;

217 9 get_child 0 4 430 20 AnimGroup::get_child 0 1 4 46
/**
 * Returns the nth child of the group.
 */
45
AnimGroup *AnimGroup::get_child(int n) const;

218 15 get_child_named 0 4 430 26 AnimGroup::get_child_named 0 1 5 250
/**
 * Returns the first child found with the indicated name, or NULL if no such
 * child exists.  This method searches only the children of this particular
 * AnimGroup; it does not recursively search the entire graph.  See also
 * find_child().
 */
69
AnimGroup *AnimGroup::get_child_named(std::string const &name) const;

219 10 find_child 0 4 430 21 AnimGroup::find_child 0 1 6 210
/**
 * Returns the first descendant found with the indicated name, or NULL if no
 * such descendant exists.  This method searches the entire graph beginning at
 * this AnimGroup; see also get_child_named().
 */
64
AnimGroup *AnimGroup::find_child(std::string const &name) const;

220 16 sort_descendants 0 4 430 27 AnimGroup::sort_descendants 0 1 7 262
/**
 * Sorts the children nodes at each level of the hierarchy into alphabetical
 * order.  This should be done after creating the hierarchy, to guarantee that
 * the correct names will match up together when the AnimBundle is later bound
 * to a PlayerRoot.
 */
39
void AnimGroup::sort_descendants(void);

221 6 output 0 6 430 17 AnimGroup::output 0 1 8 54
/**
 * Writes a one-line description of the group.
 */
56
virtual void AnimGroup::output(std::ostream &out) const;

222 5 write 0 6 430 16 AnimGroup::write 0 1 9 78
/**
 * Writes a brief description of the group and all of its descendants.
 */
73
virtual void AnimGroup::write(std::ostream &out, int indent_level) const;

223 14 get_class_type 0 4 430 25 AnimGroup::get_class_type 0 1 10 0
50
static TypeHandle AnimGroup::get_class_type(void);

224 10 AnimBundle 0 4 434 22 AnimBundle::AnimBundle 0 2 13 14 207
/**
 *
 */

/**
 *
 */

/**
 * Creates a new AnimBundle, just like this one, without copying any children.
 * The new copy is added to the indicated parent.  Intended to be called by
 * make_copy() only.
 */
158
inline explicit AnimBundle::AnimBundle(std::string const &name, PN_stdfloat fps, int num_frames);
inline AnimBundle::AnimBundle(AnimBundle const &) = default;

225 11 copy_bundle 0 4 434 23 AnimBundle::copy_bundle 0 1 15 236
/**
 * Returns a full copy of the bundle and its entire tree of nested AnimGroups.
 * However, the actual data stored in the leaves--that is, animation tables,
 * such as those stored in an AnimChannelMatrixXfmTable--will be shared.
 */
60
PointerTo< AnimBundle > AnimBundle::copy_bundle(void) const;

226 19 get_base_frame_rate 0 4 434 31 AnimBundle::get_base_frame_rate 0 1 16 307
/**
 * Returns the ideal number of frames per second of the animation, when it is
 * running at normal speed.  This may not be the same as the actual playing
 * frame rate, as it might have been adjusted through set_play_rate() on the
 * AnimControl object.  See AnimControl::get_effective_frame_rate().
 */
58
inline double AnimBundle::get_base_frame_rate(void) const;

227 14 get_num_frames 0 4 434 26 AnimBundle::get_num_frames 0 1 17 109
/**
 * Returns the number of frames of animation, or 0 if the animation has no
 * fixed number of frames.
 */
50
inline int AnimBundle::get_num_frames(void) const;

228 14 get_class_type 0 4 434 26 AnimBundle::get_class_type 0 1 18 0
51
static TypeHandle AnimBundle::get_class_type(void);

229 11 ~AnimBundle 0 4 434 23 AnimBundle::~AnimBundle 0 0 0
30
AnimBundle::~AnimBundle(void);

230 14 AnimBundleNode 0 4 437 30 AnimBundleNode::AnimBundleNode 0 1 19 330
/**
 * The AnimBundle and its node should be constructed together.  Generally, the
 * derived classes of AnimBundleNode will automatically create a AnimBundle of
 * the appropriate type, and pass it up to this constructor.
 */

/**
 * For internal use only.
 */

/**
 * Use make_copy() or copy_subgraph() to copy one of these.
 */
92
inline explicit AnimBundleNode::AnimBundleNode(std::string const &name, AnimBundle *bundle);

231 10 get_bundle 0 4 437 26 AnimBundleNode::get_bundle 0 1 20 10
/**
 *
 */
58
inline AnimBundle *AnimBundleNode::get_bundle(void) const;

232 16 find_anim_bundle 0 4 437 32 AnimBundleNode::find_anim_bundle 0 1 21 205
/**
 * Recursively walks the scene graph beginning at the indicated node (which
 * need not be an AnimBundleNode), and returns the first AnimBundle found.
 * Returns NULL if no AnimBundle can be found.
 */
69
static AnimBundle *AnimBundleNode::find_anim_bundle(PandaNode *root);

233 14 get_class_type 0 4 437 30 AnimBundleNode::get_class_type 0 1 22 0
55
static TypeHandle AnimBundleNode::get_class_type(void);

234 15 ~AnimBundleNode 0 4 437 31 AnimBundleNode::~AnimBundleNode 0 0 0
38
AnimBundleNode::~AnimBundleNode(void);

235 37 upcast_to_TypedWritableReferenceCount 0 12 440 48 PartGroup::upcast_to_TypedWritableReferenceCount 0 1 41 52
upcast from PartGroup to TypedWritableReferenceCount
84
TypedWritableReferenceCount *PartGroup::upcast_to_TypedWritableReferenceCount(void);

236 21 downcast_to_PartGroup 0 12 431 50 TypedWritableReferenceCount::downcast_to_PartGroup 0 0 54
downcast from TypedWritableReferenceCount to PartGroup
68
PartGroup *TypedWritableReferenceCount::downcast_to_PartGroup(void);

237 17 upcast_to_Namable 0 12 440 28 PartGroup::upcast_to_Namable 0 1 42 32
upcast from PartGroup to Namable
44
Namable *PartGroup::upcast_to_Namable(void);

238 21 downcast_to_PartGroup 0 12 432 30 Namable::downcast_to_PartGroup 0 0 34
downcast from Namable to PartGroup
48
PartGroup *Namable::downcast_to_PartGroup(void);

239 9 PartGroup 0 4 440 20 PartGroup::PartGroup 0 1 23 501
// This is the normal PartGroup constructor.

/**
 * This constructor is only intended for interal use and for derived classes.
 * You should normally use the non-default constructor, below.
 */

/**
 * This constructor is only intended for interal use and for derived classes.
 * You should normally use the make_copy() interface to make copies..
 */

/**
 * Creates the PartGroup, and adds it to the indicated parent.  The only way
 * to delete it subsequently is to delete the entire hierarchy.
 */
74
explicit PartGroup::PartGroup(PartGroup *parent, std::string const &name);

240 10 ~PartGroup 0 6 440 21 PartGroup::~PartGroup 0 0 10
/**
 *
 */
36
virtual PartGroup::~PartGroup(void);

241 18 is_character_joint 0 6 440 29 PartGroup::is_character_joint 0 1 24 156
/**
 * Returns true if this part is a CharacterJoint, false otherwise.  This is a
 * tiny optimization over is_of_type(CharacterType::get_class_type()).
 */
55
virtual bool PartGroup::is_character_joint(void) const;

242 9 make_copy 0 6 440 20 PartGroup::make_copy 0 1 25 110
/**
 * Allocates and returns a new copy of the node.  Children are not copied, but
 * see copy_subgraph().
 */
52
virtual PartGroup *PartGroup::make_copy(void) const;

243 13 copy_subgraph 0 4 440 24 PartGroup::copy_subgraph 0 1 26 84
/**
 * Allocates and returns a new copy of this node and of all of its children.
 */
48
PartGroup *PartGroup::copy_subgraph(void) const;

244 16 get_num_children 0 4 440 27 PartGroup::get_num_children 0 1 27 58
/**
 * Returns the number of child nodes of the group.
 */
44
int PartGroup::get_num_children(void) const;

245 9 get_child 0 4 440 20 PartGroup::get_child 0 1 28 46
/**
 * Returns the nth child of the group.
 */
45
PartGroup *PartGroup::get_child(int n) const;

246 15 get_child_named 0 4 440 26 PartGroup::get_child_named 0 1 29 250
/**
 * Returns the first child found with the indicated name, or NULL if no such
 * child exists.  This method searches only the children of this particular
 * PartGroup; it does not recursively search the entire graph.  See also
 * find_child().
 */
69
PartGroup *PartGroup::get_child_named(std::string const &name) const;

247 10 find_child 0 4 440 21 PartGroup::find_child 0 1 30 210
/**
 * Returns the first descendant found with the indicated name, or NULL if no
 * such descendant exists.  This method searches the entire graph beginning at
 * this PartGroup; see also get_child_named().
 */
64
PartGroup *PartGroup::find_child(std::string const &name) const;

248 16 sort_descendants 0 4 440 27 PartGroup::sort_descendants 0 1 31 262
/**
 * Sorts the children nodes at each level of the hierarchy into alphabetical
 * order.  This should be done after creating the hierarchy, to guarantee that
 * the correct names will match up together when the AnimBundle is later bound
 * to a PlayerRoot.
 */
39
void PartGroup::sort_descendants(void);

249 12 apply_freeze 0 4 440 23 PartGroup::apply_freeze 0 1 32 287
/**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */
62
bool PartGroup::apply_freeze(TransformState const *transform);

250 19 apply_freeze_matrix 0 6 440 30 PartGroup::apply_freeze_matrix 0 1 33 287
/**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */
112
virtual bool PartGroup::apply_freeze_matrix(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale);

251 19 apply_freeze_scalar 0 6 440 30 PartGroup::apply_freeze_scalar 0 1 34 287
/**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */
63
virtual bool PartGroup::apply_freeze_scalar(PN_stdfloat value);

252 13 apply_control 0 6 440 24 PartGroup::apply_control 0 1 35 311
/**
 * Specifies a node to influence this particular joint so that it will always
 * hold the node's transform.  Returns true if this is a joint that can be so
 * controlled, false otherwise.
 *
 * This is normally only called internally by PartBundle::control_joint(), but
 * you may also call it directly.
 */
55
virtual bool PartGroup::apply_control(PandaNode *node);

253 20 clear_forced_channel 0 6 440 31 PartGroup::clear_forced_channel 0 1 36 261
/**
 * Undoes the effect of a previous call to apply_freeze() or apply_control().
 * Returns true if the joint was modified, false otherwise.
 *
 * This is normally only called internally by PartBundle::release_joint(), but
 * you may also call it directly.
 */
51
virtual bool PartGroup::clear_forced_channel(void);

254 18 get_forced_channel 0 6 440 29 PartGroup::get_forced_channel 0 1 37 181
/**
 * Returns the AnimChannelBase that has been forced to this joint by a
 * previous call to apply_freeze() or apply_control(), or NULL if no such
 * channel has been applied.
 */
67
virtual AnimChannelBase *PartGroup::get_forced_channel(void) const;

255 5 write 0 6 440 16 PartGroup::write 0 1 38 78
/**
 * Writes a brief description of the group and all of its descendants.
 */
73
virtual void PartGroup::write(std::ostream &out, int indent_level) const;

256 16 write_with_value 0 6 440 27 PartGroup::write_with_value 0 1 39 117
/**
 * Writes a brief description of the group, showing its current value, and
 * that of all of its descendants.
 */
84
virtual void PartGroup::write_with_value(std::ostream &out, int indent_level) const;

257 14 get_class_type 0 4 440 25 PartGroup::get_class_type 0 1 40 0
50
static TypeHandle PartGroup::get_class_type(void);

258 29 upcast_to_TypedReferenceCount 0 12 443 42 AnimControl::upcast_to_TypedReferenceCount 0 1 56 46
upcast from AnimControl to TypedReferenceCount
70
TypedReferenceCount *AnimControl::upcast_to_TypedReferenceCount(void);

259 23 downcast_to_AnimControl 0 12 444 44 TypedReferenceCount::downcast_to_AnimControl 0 0 48
downcast from TypedReferenceCount to AnimControl
64
AnimControl *TypedReferenceCount::downcast_to_AnimControl(void);

260 23 upcast_to_AnimInterface 0 12 443 36 AnimControl::upcast_to_AnimInterface 0 1 57 40
upcast from AnimControl to AnimInterface
58
AnimInterface *AnimControl::upcast_to_AnimInterface(void);

261 23 downcast_to_AnimControl 0 12 445 38 AnimInterface::downcast_to_AnimControl 0 0 42
downcast from AnimInterface to AnimControl
58
AnimControl *AnimInterface::downcast_to_AnimControl(void);

262 17 upcast_to_Namable 0 12 443 30 AnimControl::upcast_to_Namable 0 1 58 34
upcast from AnimControl to Namable
46
Namable *AnimControl::upcast_to_Namable(void);

263 23 downcast_to_AnimControl 0 12 432 32 Namable::downcast_to_AnimControl 0 0 36
downcast from Namable to AnimControl
52
AnimControl *Namable::downcast_to_AnimControl(void);

264 12 ~AnimControl 0 6 443 25 AnimControl::~AnimControl 0 0 10
/**
 *
 */
40
virtual AnimControl::~AnimControl(void);

265 10 is_pending 0 4 443 23 AnimControl::is_pending 0 1 43 286
/**
 * Returns true if the AnimControl is being bound asynchronously, and has not
 * yet finished.  If this is true, the AnimControl's interface is still
 * available and will be perfectly useful (though get_anim() might return
 * NULL), but nothing visible will happen immediately.
 */
48
inline bool AnimControl::is_pending(void) const;

266 12 wait_pending 0 4 443 25 AnimControl::wait_pending 0 1 44 102
/**
 * Blocks the current thread until the AnimControl has finished loading and is
 * fully bound.
 */
37
void AnimControl::wait_pending(void);

267 8 has_anim 0 4 443 21 AnimControl::has_anim 0 1 45 154
/**
 * Returns true if the AnimControl was successfully loaded, or false if there
 * was a problem.  This may return false while is_pending() is true.
 */
46
inline bool AnimControl::has_anim(void) const;

268 22 set_pending_done_event 0 4 443 35 AnimControl::set_pending_done_event 0 1 46 205
/**
 * Specifies an event name that will be thrown when the AnimControl is
 * finished binding asynchronously.  If the AnimControl has already finished
 * binding, the event will be thrown immediately.
 */
72
void AnimControl::set_pending_done_event(std::string const &done_event);

269 22 get_pending_done_event 0 4 443 35 AnimControl::get_pending_done_event 0 1 47 113
/**
 * Returns the event name that will be thrown when the AnimControl is finished
 * binding asynchronously.
 */
60
std::string AnimControl::get_pending_done_event(void) const;

270 8 get_part 0 4 443 21 AnimControl::get_part 0 1 48 65
/**
 * Returns the PartBundle bound in with this AnimControl.
 */
46
PartBundle *AnimControl::get_part(void) const;

271 8 get_anim 0 4 443 21 AnimControl::get_anim 0 1 49 65
/**
 * Returns the AnimBundle bound in with this AnimControl.
 */
53
inline AnimBundle *AnimControl::get_anim(void) const;

272 17 get_channel_index 0 4 443 30 AnimControl::get_channel_index 0 1 50 358
/**
 * Returns the particular channel index associated with this AnimControl.
 * This channel index is the slot on which each AnimGroup is bound to its
 * associated PartGroup, for each joint in the animation.
 *
 * It will be true that
 * get_part()->find_child("n")->get_bound(get_channel_index()) ==
 * get_anim()->find_child("n"), for each joint "n".
 */
54
inline int AnimControl::get_channel_index(void) const;

273 16 get_bound_joints 0 4 443 29 AnimControl::get_bound_joints 0 1 51 369
/**
 * Returns the subset of joints controlled by this AnimControl.  Most of the
 * time, this will be BitArray::all_on(), for a normal full-body animation.
 * For a subset animation, however, this will be just a subset of those bits,
 * corresponding to the set of joints and sliders actually bound (as
 * enumerated by bind_hierarchy() in depth-first LIFO order).
 */
65
inline BitArray const &AnimControl::get_bound_joints(void) const;

274 14 set_anim_model 0 4 443 27 AnimControl::set_anim_model 0 1 52 515
/**
 * Associates the indicated PandaNode with the AnimControl.  By convention,
 * this node represents the root node of the model file that corresponds to
 * this AnimControl's animation file, though nothing in this code makes this
 * assumption or indeed does anything with this node.
 *
 * The purpose of this is simply to allow the AnimControl to keep a reference
 * count on the ModelRoot node that generated it, so that the model will not
 * disappear from the model pool until it is no longer referenced.
 */
58
inline void AnimControl::set_anim_model(PandaNode *model);

275 14 get_anim_model 0 4 443 27 AnimControl::get_anim_model 0 1 53 81
/**
 * Retrieves the pointer set via set_anim_model().  See set_anim_model().
 */
58
inline PandaNode *AnimControl::get_anim_model(void) const;

276 6 output 0 6 443 19 AnimControl::output 0 1 54 10
/**
 *
 */
58
virtual void AnimControl::output(std::ostream &out) const;

277 14 get_class_type 0 4 443 27 AnimControl::get_class_type 0 1 55 0
52
static TypeHandle AnimControl::get_class_type(void);

278 8 get_type 0 6 446 25 AnimChannelBase::get_type 0 1 59 0
57
virtual TypeHandle AnimChannelBase::get_type(void) const;

279 14 get_class_type 0 4 446 31 AnimChannelBase::get_class_type 0 1 60 0
56
static TypeHandle AnimChannelBase::get_class_type(void);

280 16 ~AnimChannelBase 0 4 446 33 AnimChannelBase::~AnimChannelBase 0 0 0
40
AnimChannelBase::~AnimChannelBase(void);

281 9 get_value 0 6 447 44 AnimChannel< ACMatrixSwitchType >::get_value 0 1 61 0
90
virtual void AnimChannel< ACMatrixSwitchType >::get_value(int frame, LMatrix4 &value) = 0;

282 24 get_value_no_scale_shear 0 6 447 59 AnimChannel< ACMatrixSwitchType >::get_value_no_scale_shear 0 1 62 72
// These transform-component methods only have meaning for matrix types.
101
virtual void AnimChannel< ACMatrixSwitchType >::get_value_no_scale_shear(int frame, LMatrix4 &value);

283 9 get_scale 0 6 447 44 AnimChannel< ACMatrixSwitchType >::get_scale 0 1 63 0
87
virtual void AnimChannel< ACMatrixSwitchType >::get_scale(int frame, LVecBase3 &scale);

284 7 get_hpr 0 6 447 42 AnimChannel< ACMatrixSwitchType >::get_hpr 0 1 64 0
83
virtual void AnimChannel< ACMatrixSwitchType >::get_hpr(int frame, LVecBase3 &hpr);

285 8 get_quat 0 6 447 43 AnimChannel< ACMatrixSwitchType >::get_quat 0 1 65 0
87
virtual void AnimChannel< ACMatrixSwitchType >::get_quat(int frame, LQuaternion &quat);

286 7 get_pos 0 6 447 42 AnimChannel< ACMatrixSwitchType >::get_pos 0 1 66 0
83
virtual void AnimChannel< ACMatrixSwitchType >::get_pos(int frame, LVecBase3 &pos);

287 9 get_shear 0 6 447 44 AnimChannel< ACMatrixSwitchType >::get_shear 0 1 67 0
87
virtual void AnimChannel< ACMatrixSwitchType >::get_shear(int frame, LVecBase3 &shear);

288 14 get_value_type 0 6 447 49 AnimChannel< ACMatrixSwitchType >::get_value_type 0 1 68 0
81
virtual TypeHandle AnimChannel< ACMatrixSwitchType >::get_value_type(void) const;

289 14 get_class_type 0 4 447 49 AnimChannel< ACMatrixSwitchType >::get_class_type 0 1 69 0
74
static TypeHandle AnimChannel< ACMatrixSwitchType >::get_class_type(void);

290 9 get_value 0 6 451 44 AnimChannel< ACScalarSwitchType >::get_value 0 0 0
93
virtual void AnimChannel< ACScalarSwitchType >::get_value(int frame, PN_stdfloat &value) = 0;

291 24 get_value_no_scale_shear 0 6 451 59 AnimChannel< ACScalarSwitchType >::get_value_no_scale_shear 0 0 72
// These transform-component methods only have meaning for matrix types.
104
virtual void AnimChannel< ACScalarSwitchType >::get_value_no_scale_shear(int frame, PN_stdfloat &value);

292 9 get_scale 0 6 451 44 AnimChannel< ACScalarSwitchType >::get_scale 0 1 70 0
87
virtual void AnimChannel< ACScalarSwitchType >::get_scale(int frame, LVecBase3 &scale);

293 7 get_hpr 0 6 451 42 AnimChannel< ACScalarSwitchType >::get_hpr 0 1 71 0
83
virtual void AnimChannel< ACScalarSwitchType >::get_hpr(int frame, LVecBase3 &hpr);

294 8 get_quat 0 6 451 43 AnimChannel< ACScalarSwitchType >::get_quat 0 1 72 0
87
virtual void AnimChannel< ACScalarSwitchType >::get_quat(int frame, LQuaternion &quat);

295 7 get_pos 0 6 451 42 AnimChannel< ACScalarSwitchType >::get_pos 0 1 73 0
83
virtual void AnimChannel< ACScalarSwitchType >::get_pos(int frame, LVecBase3 &pos);

296 9 get_shear 0 6 451 44 AnimChannel< ACScalarSwitchType >::get_shear 0 1 74 0
87
virtual void AnimChannel< ACScalarSwitchType >::get_shear(int frame, LVecBase3 &shear);

297 14 get_value_type 0 6 451 49 AnimChannel< ACScalarSwitchType >::get_value_type 0 1 75 0
81
virtual TypeHandle AnimChannel< ACScalarSwitchType >::get_value_type(void) const;

298 14 get_class_type 0 4 451 49 AnimChannel< ACScalarSwitchType >::get_class_type 0 1 76 0
74
static TypeHandle AnimChannel< ACScalarSwitchType >::get_class_type(void);

299 9 set_value 0 4 453 35 AnimChannelMatrixDynamic::set_value 0 2 77 78 153
/**
 * Explicitly sets the matrix value.
 */

/**
 * Explicitly sets the matrix value, using the indicated TransformState object
 * as a convenience.
 */
135
void AnimChannelMatrixDynamic::set_value(LMatrix4 const &value);
void AnimChannelMatrixDynamic::set_value(TransformState const *value);

300 14 set_value_node 0 4 453 40 AnimChannelMatrixDynamic::set_value_node 0 1 79 124
/**
 * Specifies a node whose transform will be queried each frame to implicitly
 * specify the transform of this joint.
 */
63
void AnimChannelMatrixDynamic::set_value_node(PandaNode *node);

301 19 get_value_transform 0 4 453 45 AnimChannelMatrixDynamic::get_value_transform 0 1 80 93
/**
 * Returns the explicit TransformState value that was set via set_value(), if
 * any.
 */
87
inline TransformState const *AnimChannelMatrixDynamic::get_value_transform(void) const;

302 14 get_value_node 0 4 453 40 AnimChannelMatrixDynamic::get_value_node 0 1 81 70
/**
 * Returns the node that was set via set_value_node(), if any.
 */
71
inline PandaNode *AnimChannelMatrixDynamic::get_value_node(void) const;

303 14 get_class_type 0 4 453 40 AnimChannelMatrixDynamic::get_class_type 0 1 82 0
65
static TypeHandle AnimChannelMatrixDynamic::get_class_type(void);

304 25 ~AnimChannelMatrixDynamic 0 4 453 51 AnimChannelMatrixDynamic::~AnimChannelMatrixDynamic 0 0 0
58
AnimChannelMatrixDynamic::~AnimChannelMatrixDynamic(void);

305 25 AnimChannelMatrixXfmTable 0 4 455 52 AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable 0 1 83 248
/**
 * Used only for bam loader.
 */

/**
 * Creates a new AnimChannelMatrixXfmTable, just like this one, without
 * copying any children.  The new copy is added to the indicated parent.
 * Intended to be called by make_copy() only.
 */

/**
 *
 */
106
explicit AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable(AnimGroup *parent, std::string const &name);

306 11 is_valid_id 0 4 455 38 AnimChannelMatrixXfmTable::is_valid_id 0 1 84 80
/**
 * Returns true if the given letter is one of the nine valid table id's.
 */
73
static inline bool AnimChannelMatrixXfmTable::is_valid_id(char table_id);

307 9 set_table 0 4 455 36 AnimChannelMatrixXfmTable::set_table 0 1 85 255
/**
 * Assigns the indicated table.  table_id is one of 'i', 'j', 'k', for scale,
 * 'a', 'b', 'c' for shear, 'h', 'p', 'r', for rotation, and 'x', 'y', 'z',
 * for translation.  The new table must have either zero, one, or
 * get_num_frames() frames.
 */
85
void AnimChannelMatrixXfmTable::set_table(char table_id, CPTA_stdfloat const &table);

308 9 get_table 0 4 455 36 AnimChannelMatrixXfmTable::get_table 0 1 86 103
/**
 * Returns a pointer to the indicated subtable's data, if it exists, or NULL
 * if it does not.
 */
79
inline CPTA_stdfloat AnimChannelMatrixXfmTable::get_table(char table_id) const;

309 16 clear_all_tables 0 4 455 43 AnimChannelMatrixXfmTable::clear_all_tables 0 1 87 90
/**
 * Removes all the tables from the channel, and resets it to its initial
 * state.
 */
55
void AnimChannelMatrixXfmTable::clear_all_tables(void);

310 9 has_table 0 4 455 36 AnimChannelMatrixXfmTable::has_table 0 1 88 68
/**
 * Returns true if the indicated subtable has been assigned.
 */
70
inline bool AnimChannelMatrixXfmTable::has_table(char table_id) const;

311 11 clear_table 0 4 455 38 AnimChannelMatrixXfmTable::clear_table 0 1 89 59
/**
 * Removes the indicated table from the definition.
 */
66
inline void AnimChannelMatrixXfmTable::clear_table(char table_id);

312 14 get_class_type 0 4 455 41 AnimChannelMatrixXfmTable::get_class_type 0 1 90 0
66
static TypeHandle AnimChannelMatrixXfmTable::get_class_type(void);

313 9 set_value 0 4 459 35 AnimChannelScalarDynamic::set_value 0 1 91 98
/**
 * Explicitly sets the value.  This will remove any node assigned via
 * set_value_node().
 */
60
void AnimChannelScalarDynamic::set_value(PN_stdfloat value);

314 14 set_value_node 0 4 459 40 AnimChannelScalarDynamic::set_value_node 0 1 92 178
/**
 * Specifies a node whose transform will be queried each frame to implicitly
 * specify the transform of this joint.  This will override the values set by
 * set_value().
 */
63
void AnimChannelScalarDynamic::set_value_node(PandaNode *node);

315 9 get_value 0 4 459 35 AnimChannelScalarDynamic::get_value 0 0 235
/**
 * Gets the value of the channel.  This will return the value explicitly
 * specified by set_value() unless a value node was specified using
 * set_value_node().
 */

/**
 * Gets the value of the channel at the indicated frame.
 */
67
inline PN_stdfloat AnimChannelScalarDynamic::get_value(void) const;

316 14 get_value_node 0 4 459 40 AnimChannelScalarDynamic::get_value_node 0 0 70
/**
 * Returns the node that was set via set_value_node(), if any.
 */
71
inline PandaNode *AnimChannelScalarDynamic::get_value_node(void) const;

317 14 get_class_type 0 4 459 40 AnimChannelScalarDynamic::get_class_type 0 1 93 0
65
static TypeHandle AnimChannelScalarDynamic::get_class_type(void);

318 25 ~AnimChannelScalarDynamic 0 4 459 51 AnimChannelScalarDynamic::~AnimChannelScalarDynamic 0 0 0
58
AnimChannelScalarDynamic::~AnimChannelScalarDynamic(void);

319 9 set_table 0 4 462 33 AnimChannelScalarTable::set_table 0 1 94 34
/**
 * Assigns the data table.
 */
67
void AnimChannelScalarTable::set_table(CPTA_stdfloat const &table);

320 9 get_table 0 4 462 33 AnimChannelScalarTable::get_table 0 1 95 90
/**
 * Returns a pointer to the table's data, if it exists, or NULL if it does
 * not.
 */
67
inline CPTA_stdfloat AnimChannelScalarTable::get_table(void) const;

321 9 has_table 0 4 462 33 AnimChannelScalarTable::has_table 0 1 96 60
/**
 * Returns true if the data table has been assigned.
 */
58
inline bool AnimChannelScalarTable::has_table(void) const;

322 11 clear_table 0 4 462 35 AnimChannelScalarTable::clear_table 0 1 97 34
/**
 * Empties the data table.
 */
54
inline void AnimChannelScalarTable::clear_table(void);

323 14 get_class_type 0 4 462 38 AnimChannelScalarTable::get_class_type 0 1 98 0
63
static TypeHandle AnimChannelScalarTable::get_class_type(void);

324 23 ~AnimChannelScalarTable 0 4 462 47 AnimChannelScalarTable::~AnimChannelScalarTable 0 0 0
54
AnimChannelScalarTable::~AnimChannelScalarTable(void);

325 21 AnimControlCollection 0 4 463 44 AnimControlCollection::AnimControlCollection 0 2 99 100 117
/**
 * Returns the AnimControl associated with the given name, or NULL if no such
 * control has been associated.
 */
145
AnimControlCollection::AnimControlCollection(void);
inline AnimControlCollection::AnimControlCollection(AnimControlCollection const &) = default;

326 22 ~AnimControlCollection 0 4 463 45 AnimControlCollection::~AnimControlCollection 0 0 10
/**
 *
 */
52
AnimControlCollection::~AnimControlCollection(void);

327 10 store_anim 0 4 463 33 AnimControlCollection::store_anim 0 1 101 247
/**
 * Associates the given AnimControl with this collection under the given name.
 * The AnimControl will remain associated until a new AnimControl is
 * associated with the same name later, or until unbind_anim() is called with
 * this name.
 */
86
void AnimControlCollection::store_anim(AnimControl *control, std::string const &name);

328 9 find_anim 0 4 463 32 AnimControlCollection::find_anim 0 1 102 117
/**
 * Returns the AnimControl associated with the given name, or NULL if no such
 * control has been associated.
 */
77
AnimControl *AnimControlCollection::find_anim(std::string const &name) const;

329 11 unbind_anim 0 4 463 34 AnimControlCollection::unbind_anim 0 1 103 184
/**
 * Removes the AnimControl associated with the given name, if any.  Returns
 * true if an AnimControl was removed, false if there was no AnimControl with
 * the indicated name.
 */
65
bool AnimControlCollection::unbind_anim(std::string const &name);

330 13 get_num_anims 0 4 463 36 AnimControlCollection::get_num_anims 0 1 104 78
/**
 * Returns the number of AnimControls associated with this collection.
 */
53
int AnimControlCollection::get_num_anims(void) const;

331 8 get_anim 0 4 463 31 AnimControlCollection::get_anim 0 1 105 71
/**
 * Returns the nth AnimControl associated with this collection.
 */
58
AnimControl *AnimControlCollection::get_anim(int n) const;

332 13 get_anim_name 0 4 463 36 AnimControlCollection::get_anim_name 0 1 106 83
/**
 * Returns the name of the nth AnimControl associated with this collection.
 */
62
std::string AnimControlCollection::get_anim_name(int n) const;

333 11 clear_anims 0 4 463 34 AnimControlCollection::clear_anims 0 1 107 56
/**
 * Disassociates all anims from this collection.
 */
46
void AnimControlCollection::clear_anims(void);

334 4 play 0 4 463 27 AnimControlCollection::play 0 2 108 109 94
/**
 * Starts the named animation playing.
 */

/**
 * Starts the named animation playing.
 */
165
inline bool AnimControlCollection::play(std::string const &anim_name);
inline bool AnimControlCollection::play(std::string const &anim_name, double from, double to);

335 4 loop 0 4 463 27 AnimControlCollection::loop 0 2 110 111 94
/**
 * Starts the named animation looping.
 */

/**
 * Starts the named animation looping.
 */
193
inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart);
inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart, double from, double to);

336 4 stop 0 4 463 27 AnimControlCollection::stop 0 1 112 37
/**
 * Stops the named animation.
 */
70
inline bool AnimControlCollection::stop(std::string const &anim_name);

337 4 pose 0 4 463 27 AnimControlCollection::pose 0 1 113 61
/**
 * Sets to a particular frame in the named animation.
 */
84
inline bool AnimControlCollection::pose(std::string const &anim_name, double frame);

338 8 play_all 0 4 463 31 AnimControlCollection::play_all 0 2 114 115 134
// These functions operate on all anims at once.

/**
 * Starts all animations playing.
 */

/**
 * Starts all animations playing.
 */
105
void AnimControlCollection::play_all(void);
void AnimControlCollection::play_all(double from, double to);

339 8 loop_all 0 4 463 31 AnimControlCollection::loop_all 0 2 116 117 84
/**
 * Starts all animations looping.
 */

/**
 * Starts all animations looping.
 */
127
void AnimControlCollection::loop_all(bool restart);
void AnimControlCollection::loop_all(bool restart, double from, double to);

340 8 stop_all 0 4 463 31 AnimControlCollection::stop_all 0 1 118 127
/**
 * Stops all currently playing animations.  Returns true if any animations
 * were stopped, false if none were playing.
 */
43
bool AnimControlCollection::stop_all(void);

341 8 pose_all 0 4 463 31 AnimControlCollection::pose_all 0 1 119 54
/**
 * Sets all animations to the indicated frame.
 */
51
void AnimControlCollection::pose_all(double frame);

342 9 get_frame 0 4 463 32 AnimControlCollection::get_frame 0 2 120 121 168
/**
 * Returns the current frame in the named animation, or 0 if the animation is
 * not found.
 */

/**
 * Returns the current frame in the last-started animation.
 */
137
inline int AnimControlCollection::get_frame(std::string const &anim_name) const;
inline int AnimControlCollection::get_frame(void) const;

343 14 get_num_frames 0 4 463 37 AnimControlCollection::get_num_frames 0 2 122 123 186
/**
 * Returns the total number of frames in the named animation, or 0 if the
 * animation is not found.
 */

/**
 * Returns the total number of frames in the last-started animation.
 */
147
inline int AnimControlCollection::get_num_frames(std::string const &anim_name) const;
inline int AnimControlCollection::get_num_frames(void) const;

344 10 is_playing 0 4 463 33 AnimControlCollection::is_playing 0 2 124 125 182
/**
 * Returns true if the named animation is currently playing, false otherwise.
 */

/**
 * Returns true if the last-started animation is currently playing, false
 * otherwise.
 */
141
inline bool AnimControlCollection::is_playing(std::string const &anim_name) const;
inline bool AnimControlCollection::is_playing(void) const;

345 18 which_anim_playing 0 4 463 41 AnimControlCollection::which_anim_playing 0 1 126 183
/**
 * Returns the name of the bound AnimControl currently playing, if any.  If
 * more than one AnimControl is currently playing, returns all of the names
 * separated by spaces.
 */
66
std::string AnimControlCollection::which_anim_playing(void) const;

346 6 output 0 4 463 29 AnimControlCollection::output 0 1 127 10
/**
 *
 */
60
void AnimControlCollection::output(std::ostream &out) const;

347 5 write 0 4 463 28 AnimControlCollection::write 0 1 128 10
/**
 *
 */
59
void AnimControlCollection::write(std::ostream &out) const;

348 16 AnimPreloadTable 0 4 464 34 AnimPreloadTable::AnimPreloadTable 0 1 129 10
/**
 *
 */
41
AnimPreloadTable::AnimPreloadTable(void);

349 13 get_num_anims 0 4 464 31 AnimPreloadTable::get_num_anims 0 1 130 64
/**
 * Returns the number of animation records in the table.
 */
48
int AnimPreloadTable::get_num_anims(void) const;

350 9 find_anim 0 4 464 27 AnimPreloadTable::find_anim 0 1 131 321
/**
 * Returns the index number in the table of the animation record with the
 * indicated name, or -1 if the name is not present.  By convention, the
 * basename is the filename of the egg or bam file, without the directory part
 * and without the extension.  That is, it is
 * Filename::get_basename_wo_extension().
 */
67
int AnimPreloadTable::find_anim(std::string const &basename) const;

351 12 get_basename 0 4 464 30 AnimPreloadTable::get_basename 0 1 132 86
/**
 * Returns the basename stored for the nth animation record.  See find_anim().
 */
63
inline std::string AnimPreloadTable::get_basename(int n) const;

352 19 get_base_frame_rate 0 4 464 37 AnimPreloadTable::get_base_frame_rate 0 1 133 70
/**
 * Returns the frame rate stored for the nth animation record.
 */
70
inline PN_stdfloat AnimPreloadTable::get_base_frame_rate(int n) const;

353 14 get_num_frames 0 4 464 32 AnimPreloadTable::get_num_frames 0 1 134 76
/**
 * Returns the number of frames stored for the nth animation record.
 */
57
inline int AnimPreloadTable::get_num_frames(int n) const;

354 11 clear_anims 0 4 464 29 AnimPreloadTable::clear_anims 0 1 135 56
/**
 * Removes all animation records from the table.
 */
41
void AnimPreloadTable::clear_anims(void);

355 11 remove_anim 0 4 464 29 AnimPreloadTable::remove_anim 0 1 136 113
/**
 * Removes the nth animation records from the table.  This renumbers indexes
 * for following animations.
 */
42
void AnimPreloadTable::remove_anim(int n);

356 8 add_anim 0 4 464 26 AnimPreloadTable::add_anim 0 1 137 227
/**
 * Adds a new animation record to the table.  If there is already a record of
 * this name, no operation is performed (the original record is unchanged).
 * See find_anim().  This will invalidate existing index numbers.
 */
106
void AnimPreloadTable::add_anim(std::string const &basename, PN_stdfloat base_frame_rate, int num_frames);

357 14 add_anims_from 0 4 464 32 AnimPreloadTable::add_anims_from 0 1 138 160
/**
 * Copies the animation records from the other table into this one.  If a
 * given record name exists in both tables, the record in this one supercedes.
 */
69
void AnimPreloadTable::add_anims_from(AnimPreloadTable const *other);

358 6 output 0 6 464 24 AnimPreloadTable::output 0 1 139 10
/**
 *
 */
63
virtual void AnimPreloadTable::output(std::ostream &out) const;

359 5 write 0 6 464 23 AnimPreloadTable::write 0 1 140 10
/**
 *
 */
80
virtual void AnimPreloadTable::write(std::ostream &out, int indent_level) const;

360 14 get_class_type 0 4 464 32 AnimPreloadTable::get_class_type 0 1 141 0
57
static TypeHandle AnimPreloadTable::get_class_type(void);

361 9 auto_bind 0 1 0 9 auto_bind 0 1 209 0
101
void auto_bind(PandaNode *root_node, AnimControlCollection &controls, int hierarchy_match_flags = 0);

362 10 PartSubset 0 4 466 22 PartSubset::PartSubset 0 2 142 143 22
/**
 *
 */

/**
 *
 */
77
PartSubset::PartSubset(void);
PartSubset::PartSubset(PartSubset const &copy);

363 10 operator = 0 4 466 22 PartSubset::operator = 0 1 144 0
52
void PartSubset::operator =(PartSubset const &copy);

364 17 add_include_joint 0 4 466 29 PartSubset::add_include_joint 0 1 145 342
/**
 * Adds the named joint to the list of joints that will be explicitly included
 * in the subset.  Any joint at or below a named node will be included in the
 * subset (unless a lower node is also listed in the exclude list).
 *
 * Since the name is a GlobPattern, it may of course include filename globbing
 * characters like * and ?.
 */
60
void PartSubset::add_include_joint(GlobPattern const &name);

365 17 add_exclude_joint 0 4 466 29 PartSubset::add_exclude_joint 0 1 146 352
/**
 * Adds the named joint to the list of joints that will be explicitly
 * exlcluded from the subset.  Any joint at or below a named node will not be
 * included in the subset (unless a lower node is also listed in the include
 * list).
 *
 * Since the name is a GlobPattern, it may of course include filename globbing
 * characters like * and ?.
 */
60
void PartSubset::add_exclude_joint(GlobPattern const &name);

366 6 append 0 4 466 18 PartSubset::append 0 1 147 98
/**
 * Appends the include and exclude list from the other object onto this
 * object's lists.
 */
49
void PartSubset::append(PartSubset const &other);

367 6 output 0 4 466 18 PartSubset::output 0 1 148 10
/**
 *
 */
49
void PartSubset::output(std::ostream &out) const;

368 16 is_include_empty 0 4 466 28 PartSubset::is_include_empty 0 1 149 147
/**
 * Returns true if the include list is completely empty, false otherwise.  If
 * it is empty, it is the same thing as including all joints.
 */
46
bool PartSubset::is_include_empty(void) const;

369 15 matches_include 0 4 466 27 PartSubset::matches_include 0 1 150 101
/**
 * Returns true if the indicated name matches a name on the include list,
 * false otherwise.
 */
70
bool PartSubset::matches_include(std::string const &joint_name) const;

370 15 matches_exclude 0 4 466 27 PartSubset::matches_exclude 0 1 151 101
/**
 * Returns true if the indicated name matches a name on the exclude list,
 * false otherwise.
 */
70
bool PartSubset::matches_exclude(std::string const &joint_name) const;

371 11 ~PartSubset 0 4 466 23 PartSubset::~PartSubset 0 0 0
30
PartSubset::~PartSubset(void);

372 15 BindAnimRequest 0 4 467 32 BindAnimRequest::BindAnimRequest 0 2 152 153 10
/**
 *
 */
290
explicit BindAnimRequest::BindAnimRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, Loader *loader, AnimControl *control, int hierarchy_match_flags, PartSubset const &subset);
inline BindAnimRequest::BindAnimRequest(BindAnimRequest const &) = default;

373 14 get_class_type 0 4 467 31 BindAnimRequest::get_class_type 0 1 154 0
56
static TypeHandle BindAnimRequest::get_class_type(void);

374 16 ~BindAnimRequest 0 4 467 33 BindAnimRequest::~BindAnimRequest 0 0 0
40
BindAnimRequest::~BindAnimRequest(void);

375 10 PartBundle 0 4 469 22 PartBundle::PartBundle 0 1 155 220
/**
 * Normally, you'd use make_copy() or copy_subgraph() to make a copy of this.
 */

/**
 * Normally, a PartBundle constructor should not be called directly--it will
 * get created when a PartBundleNode is created.
 */
62
explicit PartBundle::PartBundle(std::string const &name = "");

376 16 get_anim_preload 0 4 469 28 PartBundle::get_anim_preload 0 1 156 181
/**
 * Returns the AnimPreloadTable associated with the PartBundle.  This table,
 * if present, can be used for the benefit of load_bind_anim() to allow
 * asynchronous binding.
 */
83
inline ConstPointerTo< AnimPreloadTable > PartBundle::get_anim_preload(void) const;

377 19 modify_anim_preload 0 4 469 31 PartBundle::modify_anim_preload 0 1 157 106
/**
 * Returns a modifiable pointer to the AnimPreloadTable associated with the
 * PartBundle, if any.
 */
75
inline PointerTo< AnimPreloadTable > PartBundle::modify_anim_preload(void);

378 16 set_anim_preload 0 4 469 28 PartBundle::set_anim_preload 0 1 158 72
/**
 * Replaces the AnimPreloadTable associated with the PartBundle.
 */
66
inline void PartBundle::set_anim_preload(AnimPreloadTable *table);

379 18 clear_anim_preload 0 4 469 30 PartBundle::clear_anim_preload 0 1 159 71
/**
 * Removes any AnimPreloadTable associated with the PartBundle.
 */
49
inline void PartBundle::clear_anim_preload(void);

380 19 merge_anim_preloads 0 4 469 31 PartBundle::merge_anim_preloads 0 1 160 85
/**
 * Copies the contents of the other PartBundle's preload table into this one.
 */
62
void PartBundle::merge_anim_preloads(PartBundle const *other);

381 14 set_blend_type 0 4 469 26 PartBundle::set_blend_type 0 1 161 270
/**
 * Defines the algorithm that is used when blending multiple frames or
 * multiple animations together, when either anim_blend_flag or
 * frame_blend_flag is set to true.
 *
 * See partBundle.h for a description of the meaning of each of the BlendType
 * values.
 */
65
inline void PartBundle::set_blend_type(PartBundle::BlendType bt);

382 14 get_blend_type 0 4 469 26 PartBundle::get_blend_type 0 1 162 178
/**
 * Returns the algorithm that is used when blending multiple frames or
 * multiple animations together, when either anim_blend_flag or
 * frame_blend_flag is set to true.
 */
68
inline PartBundle::BlendType PartBundle::get_blend_type(void) const;

383 19 set_anim_blend_flag 0 4 469 31 PartBundle::set_anim_blend_flag 0 1 163 581
/**
 * Defines the way the character responds to multiple calls to
 * set_control_effect()).  By default, this flag is set false, which disallows
 * multiple animations.  When this flag is false, it is not necessary to
 * explicitly set the control_effect when starting an animation; starting the
 * animation will implicitly remove the control_effect from the previous
 * animation and set it on the current one.
 *
 * However, if this flag is set true, the control_effect must be explicitly
 * set via set_control_effect() whenever an animation is to affect the
 * character.
 */
59
void PartBundle::set_anim_blend_flag(bool anim_blend_flag);

384 19 get_anim_blend_flag 0 4 469 31 PartBundle::get_anim_blend_flag 0 1 164 136
/**
 * Returns whether the character allows multiple different animations to be
 * bound simultaneously.  See set_anim_blend_flag().
 */
56
inline bool PartBundle::get_anim_blend_flag(void) const;

385 20 set_frame_blend_flag 0 4 469 32 PartBundle::set_frame_blend_flag 0 1 165 775
/**
 * Specifies whether the character interpolates (blends) between two
 * sequential frames of an active animation, showing a smooth intra-frame
 * motion, or whether it holds each frame until the next frame is ready,
 * showing precisely the specified animation.
 *
 * When this value is false, the character holds each frame until the next is
 * ready.  When this is true, the character will interpolate between two
 * consecutive frames of animation for each frame the animation is onscreen,
 * according to the amount of time elapsed between the frames.
 *
 * The default value of this flag is determined by the interpolate-frames
 * Config.prc variable.
 *
 * Use set_blend_type() to change the algorithm that the character uses to
 * interpolate matrix positions.
 */
68
inline void PartBundle::set_frame_blend_flag(bool frame_blend_flag);

386 20 get_frame_blend_flag 0 4 469 32 PartBundle::get_frame_blend_flag 0 1 166 205
/**
 * Returns whether the character interpolates (blends) between two sequential
 * animation frames, or whether it holds the current frame until the next one
 * is ready.  See set_frame_blend_flag().
 */
57
inline bool PartBundle::get_frame_blend_flag(void) const;

387 14 set_root_xform 0 4 469 26 PartBundle::set_root_xform 0 1 167 111
/**
 * Specifies the transform matrix which is implicitly applied at the root of
 * the animated hierarchy.
 */
67
inline void PartBundle::set_root_xform(LMatrix4 const &root_xform);

388 5 xform 0 4 469 17 PartBundle::xform 0 1 168 81
/**
 * Applies the indicated transform to the root of the animated hierarchy.
 */
51
inline void PartBundle::xform(LMatrix4 const &mat);

389 14 get_root_xform 0 4 469 26 PartBundle::get_root_xform 0 1 169 109
/**
 * Returns the transform matrix which is implicitly applied at the root of the
 * animated hierarchy.
 */
62
inline LMatrix4 const &PartBundle::get_root_xform(void) const;

390 15 apply_transform 0 4 469 27 PartBundle::apply_transform 0 1 170 226
/**
 * Returns a PartBundle that is a duplicate of this one, but with the
 * indicated transform applied.  If this is called multiple times with the
 * same TransformState pointer, it returns the same PartBundle each time.
 */
85
PointerTo< PartBundle > PartBundle::apply_transform(TransformState const *transform);

391 13 get_num_nodes 0 4 469 25 PartBundle::get_num_nodes 0 1 171 94
/**
 * Returns the number of PartBundleNodes that contain a pointer to this
 * PartBundle.
 */
49
inline int PartBundle::get_num_nodes(void) const;

392 8 get_node 0 4 469 20 PartBundle::get_node 0 1 172 74
/**
 * Returns the nth PartBundleNode associated with this PartBundle.
 */
57
inline PartBundleNode *PartBundle::get_node(int n) const;

393 14 PartBundleNode 0 4 474 30 PartBundleNode::PartBundleNode 0 1 188 388
/**
 * The PartBundle and its node should be constructed together.  Generally, the
 * derived classes of PartBundleNode will automatically create a PartBundle of
 * the appropriate type, and pass it up to this constructor.
 */

/**
 * For internal use only.
 */

/**
 * Use make_copy() or copy_subgraph() to copy one of these.
 *
 * This constructor does not copy the bundle pointers.
 */
92
inline explicit PartBundleNode::PartBundleNode(std::string const &name, PartBundle *bundle);

394 15 get_num_bundles 0 4 474 31 PartBundleNode::get_num_bundles 0 1 189 10
/**
 *
 */
55
inline int PartBundleNode::get_num_bundles(void) const;

395 10 get_bundle 0 4 474 26 PartBundleNode::get_bundle 0 1 190 10
/**
 *
 */
59
inline PartBundle *PartBundleNode::get_bundle(int n) const;

396 17 get_bundle_handle 0 4 474 33 PartBundleNode::get_bundle_handle 0 1 191 204
/**
 * Returns the PartBundleHandle that wraps around the actual nth PartBundle.
 * While the PartBundle pointer might later change due to a future flatten
 * operation, the PartBundleHandle will not.
 */
72
inline PartBundleHandle *PartBundleNode::get_bundle_handle(int n) const;

397 16 PartBundleHandle 0 4 477 34 PartBundleHandle::PartBundleHandle 0 2 193 194 10
/**
 *
 */
141
inline PartBundleHandle::PartBundleHandle(PartBundle *bundle);
inline PartBundleHandle::PartBundleHandle(PartBundleHandle const &) = default;

398 10 get_bundle 0 4 477 28 PartBundleHandle::get_bundle 0 1 195 68
/**
 * Returns the actual PartBundle embedded within the handle.
 */
54
inline PartBundle *PartBundleHandle::get_bundle(void);

399 10 set_bundle 0 4 477 28 PartBundleHandle::set_bundle 0 1 196 68
/**
 * Changes the actual PartBundle embedded within the handle.
 */
61
inline void PartBundleHandle::set_bundle(PartBundle *bundle);

400 14 get_class_type 0 4 474 30 PartBundleNode::get_class_type 0 1 192 0
55
static TypeHandle PartBundleNode::get_class_type(void);

401 21 clear_control_effects 0 4 469 33 PartBundle::clear_control_effects 0 1 173 518
/**
 * Sets the control effect of all AnimControls to zero (but does not "stop"
 * the AnimControls).  The character will no longer be affected by any
 * animation, and will return to its default pose (unless restore-initial-pose
 * is false).
 *
 * The AnimControls which are no longer associated will not be using any CPU
 * cycles, but they may still be in the "playing" state; if they are later
 * reassociated with the PartBundle they will resume at their current frame as
 * if they'd been running all along.
 */
45
void PartBundle::clear_control_effects(void);

402 18 set_control_effect 0 4 469 30 PartBundle::set_control_effect 0 1 174 530
/**
 * Sets the amount by which the character is affected by the indicated
 * AnimControl (and its associated animation).  Normally, this will only be
 * zero or one.  Zero indicates the animation does not affect the character,
 * and one means it does.
 *
 * If the _anim_blend_flag is not false (see set_anim_blend_flag()), it is
 * possible to have multiple AnimControls in effect simultaneously.  In this
 * case, the effect is a weight that indicates the relative importance of each
 * AnimControl to the final animation.
 */
85
inline void PartBundle::set_control_effect(AnimControl *control, PN_stdfloat effect);

403 18 get_control_effect 0 4 469 30 PartBundle::get_control_effect 0 1 175 153
/**
 * Returns the amount by which the character is affected by the indicated
 * AnimControl and its associated animation.  See set_control_effect().
 */
78
inline PN_stdfloat PartBundle::get_control_effect(AnimControl *control) const;

404 6 output 0 6 469 18 PartBundle::output 0 1 176 55
/**
 * Writes a one-line description of the bundle.
 */
57
virtual void PartBundle::output(std::ostream &out) const;

405 9 bind_anim 0 4 469 21 PartBundle::bind_anim 0 1 177 790
/**
 * Binds the animation to the bundle, if possible, and returns a new
 * AnimControl that can be used to start and stop the animation.  If the anim
 * hierarchy does not match the part hierarchy, returns NULL.
 *
 * If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,
 * it may contain a union of PartGroup::HierarchyMatchFlags values indicating
 * conditions that will be tolerated (but warnings will still be issued).
 *
 * If subset is specified, it restricts the binding only to the named subtree
 * of joints.
 *
 * The AnimControl is not stored within the PartBundle; it is the user's
 * responsibility to maintain the pointer.  The animation will automatically
 * unbind itself when the AnimControl destructs (i.e.  its reference count
 * goes to zero).
 */
137
PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags = 0, PartSubset const &subset = PartSubset());

406 14 load_bind_anim 0 4 469 26 PartBundle::load_bind_anim 0 1 178 1088
/**
 * Binds an animation to the bundle.  The animation is loaded from the disk
 * via the indicated Loader object.  In other respects, this behaves similarly
 * to bind_anim(), with the addition of asynchronous support.
 *
 * If allow_aysnc is true, the load will be asynchronous if possible.  This
 * requires that the animation basename can be found in the PartBundle's
 * preload table (see get_anim_preload()).
 *
 * In an asynchronous load, the animation file will be loaded and bound in a
 * sub-thread.  This means that the animation will not necessarily be
 * available at the time this method returns.  You may still use the returned
 * AnimControl immediately, though, but no visible effect will occur until the
 * animation eventually becomes available.
 *
 * You can test AnimControl::is_pending() to see if the animation has been
 * loaded yet, or wait for it to finish with AnimControl::wait_pending() or
 * even PartBundle::wait_pending().  You can also set an event to be triggered
 * when the animation finishes loading with
 * AnimControl::set_pending_done_event().
 */
165
PointerTo< AnimControl > PartBundle::load_bind_anim(Loader *loader, Filename const &filename, int hierarchy_match_flags, PartSubset const &subset, bool allow_async);

407 12 wait_pending 0 4 469 24 PartBundle::wait_pending 0 1 179 153
/**
 * Blocks the current thread until all currently-pending AnimControls, with a
 * nonzero control effect, have been loaded and are properly bound.
 */
36
void PartBundle::wait_pending(void);

408 12 freeze_joint 0 4 469 24 PartBundle::freeze_joint 0 3 180 181 182 1123
/**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */

/**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */

/**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */
305
bool PartBundle::freeze_joint(std::string const &joint_name, TransformState const *transform);
bool PartBundle::freeze_joint(std::string const &joint_name, LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale);
bool PartBundle::freeze_joint(std::string const &joint_name, PN_stdfloat value);

409 13 control_joint 0 4 469 25 PartBundle::control_joint 0 1 183 396
/**
 * Specifies that the joint with the indicated name should be animated with
 * the transform on the indicated node.  It will henceforth always follow the
 * node's transform, regardless of any animations that may subsequently be
 * bound to the joint.
 *
 * Returns true if the joint is successfully controlled, or false if the named
 * child is not a joint (or slider) or does not exist.
 */
79
bool PartBundle::control_joint(std::string const &joint_name, PandaNode *node);

410 13 release_joint 0 4 469 25 PartBundle::release_joint 0 1 184 342
/**
 * Releases the named joint from the effects of a previous call to
 * freeze_joint() or control_joint(). It will henceforth once again follow
 * whatever transforms are dictated by the animation.
 *
 * Returns true if the joint is released, or false if the named child was not
 * previously controlled or frozen, or it does not exist.
 */
62
bool PartBundle::release_joint(std::string const &joint_name);

411 6 update 0 4 469 18 PartBundle::update 0 1 185 216
/**
 * Updates all the parts in the bundle to reflect the data for the current
 * frame (as set in each of the AnimControls).
 *
 * Returns true if any part has changed as a result of this, or false
 * otherwise.
 */
30
bool PartBundle::update(void);

412 12 force_update 0 4 469 24 PartBundle::force_update 0 1 186 131
/**
 * Updates all the parts in the bundle to reflect the data for the current
 * frame, whether we believe it needs it or not.
 */
36
bool PartBundle::force_update(void);

413 14 get_class_type 0 4 469 26 PartBundle::get_class_type 0 1 187 0
51
static TypeHandle PartBundle::get_class_type(void);

414 11 ~PartBundle 0 4 469 23 PartBundle::~PartBundle 0 0 0
30
PartBundle::~PartBundle(void);

415 13 get_max_bound 0 4 479 29 MovingPartBase::get_max_bound 0 1 197 310
/**
 * Returns the number of channels that might be bound to this PartGroup.  This
 * might not be the actual number of channels, since there might be holes in
 * the list; it is one more than the index number of the highest bound
 * channel.  Thus, it is called get_max_bound() instead of get_num_bound().
 */
53
inline int MovingPartBase::get_max_bound(void) const;

416 9 get_bound 0 4 479 25 MovingPartBase::get_bound 0 1 198 371
/**
 * Returns the nth bound channel on this PartGroup.  n can be determined by
 * iterating from 0 to one less than get_max_bound(); or n might be
 * AnimControl::get_channel_index().
 *
 * This will return NULL if there is no channel bound on the indicated index.
 * It is an error to call this if n is less than zero or greater than or equal
 * to get_max_bound().
 */
63
inline AnimChannelBase *MovingPartBase::get_bound(int n) const;

417 12 output_value 0 6 479 28 MovingPartBase::output_value 0 1 199 0
71
virtual void MovingPartBase::output_value(std::ostream &out) const = 0;

418 14 get_class_type 0 4 479 30 MovingPartBase::get_class_type 0 1 200 0
55
static TypeHandle MovingPartBase::get_class_type(void);

419 15 ~MovingPartBase 0 4 479 31 MovingPartBase::~MovingPartBase 0 0 0
38
MovingPartBase::~MovingPartBase(void);

420 14 get_class_type 0 4 481 48 MovingPart< ACMatrixSwitchType >::get_class_type 0 1 202 0
73
static TypeHandle MovingPart< ACMatrixSwitchType >::get_class_type(void);

421 9 get_value 0 4 481 43 MovingPart< ACMatrixSwitchType >::get_value 0 1 203 0
72
inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_value(void) const;

422 17 get_default_value 0 4 481 51 MovingPart< ACMatrixSwitchType >::get_default_value 0 1 204 0
80
inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_default_value(void) const;

423 11 ~MovingPart 0 4 481 45 MovingPart< ACMatrixSwitchType >::~MovingPart 0 0 0
52
MovingPart< ACMatrixSwitchType >::~MovingPart(void);

424 14 get_class_type 0 4 480 32 MovingPartMatrix::get_class_type 0 1 201 0
57
static TypeHandle MovingPartMatrix::get_class_type(void);

425 14 get_class_type 0 4 483 48 MovingPart< ACScalarSwitchType >::get_class_type 0 1 206 0
73
static TypeHandle MovingPart< ACScalarSwitchType >::get_class_type(void);

426 9 get_value 0 4 483 43 MovingPart< ACScalarSwitchType >::get_value 0 1 207 0
75
inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_value(void) const;

427 17 get_default_value 0 4 483 51 MovingPart< ACScalarSwitchType >::get_default_value 0 1 208 0
83
inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_default_value(void) const;

428 11 ~MovingPart 0 4 483 45 MovingPart< ACScalarSwitchType >::~MovingPart 0 0 0
52
MovingPart< ACScalarSwitchType >::~MovingPart(void);

429 14 get_class_type 0 4 482 32 MovingPartScalar::get_class_type 0 1 205 0
57
static TypeHandle MovingPartScalar::get_class_type(void);

209
1 0 0 7 8 433 215 0 148 /**
 * Creates the AnimGroup, and adds it to the indicated parent.  The only way
 * to delete it subsequently is to delete the entire hierarchy.
 */ 2 6 parent 1 433  4 name 1 484  
2 0 0 7 8 433 215 0 0 1 6 param0 0 485  
3 0 0 6 10 436 0 0 58 /**
 * Returns the number of child nodes of the group.
 */ 1 4 this 3 485  
4 0 0 7 11 433 215 0 46 /**
 * Returns the nth child of the group.
 */ 2 4 this 3 485  1 n 1 436  
5 0 0 7 13 433 215 0 250 /**
 * Returns the first child found with the indicated name, or NULL if no such
 * child exists.  This method searches only the children of this particular
 * AnimGroup; it does not recursively search the entire graph.  See also
 * find_child().
 */ 2 4 this 3 485  4 name 1 484  
6 0 0 7 14 433 215 0 210 /**
 * Returns the first descendant found with the indicated name, or NULL if no
 * such descendant exists.  This method searches the entire graph beginning at
 * this AnimGroup; see also get_child_named().
 */ 2 4 this 3 485  4 name 1 484  
7 0 0 4 15 487 0 0 262 /**
 * Sorts the children nodes at each level of the hierarchy into alphabetical
 * order.  This should be done after creating the hierarchy, to guarantee that
 * the correct names will match up together when the AnimBundle is later bound
 * to a PlayerRoot.
 */ 1 4 this 3 433  
8 0 0 4 18 487 0 0 54 /**
 * Writes a one-line description of the group.
 */ 2 4 this 3 485  3 out 1 488  
9 0 0 4 19 487 0 0 78 /**
 * Writes a brief description of the group and all of its descendants.
 */ 3 4 this 3 485  3 out 1 488  12 indent_level 1 436  
10 0 0 7 20 491 0 0 0 0 
11 0 0 7 3 492 0 0 0 1 4 this 3 433  
12 0 0 6 6 493 0 0 0 1 4 this 3 433  
13 0 0 7 22 439 229 0 0 1 6 param0 0 494  
14 0 0 7 22 439 229 0 10 /**
 *
 */ 3 4 name 1 484  3 fps 1 460  10 num_frames 1 436  
15 0 0 7 23 439 229 0 236 /**
 * Returns a full copy of the bundle and its entire tree of nested AnimGroups.
 * However, the actual data stored in the leaves--that is, animation tables,
 * such as those stored in an AnimChannelMatrixXfmTable--will be shared.
 */ 1 4 this 3 494  
16 0 0 6 24 435 0 0 307 /**
 * Returns the ideal number of frames per second of the animation, when it is
 * running at normal speed.  This may not be the same as the actual playing
 * frame rate, as it might have been adjusted through set_play_rate() on the
 * AnimControl object.  See AnimControl::get_effective_frame_rate().
 */ 1 4 this 3 494  
17 0 0 6 25 436 0 0 109 /**
 * Returns the number of frames of animation, or 0 if the animation has no
 * fixed number of frames.
 */ 1 4 this 3 494  
18 0 0 7 30 491 0 0 0 0 
19 0 0 7 34 496 234 0 226 /**
 * The AnimBundle and its node should be constructed together.  Generally, the
 * derived classes of AnimBundleNode will automatically create a AnimBundle of
 * the appropriate type, and pass it up to this constructor.
 */ 2 4 name 1 484  6 bundle 1 439  
20 0 0 7 35 439 229 0 10 /**
 *
 */ 1 4 this 3 497  
21 0 0 7 38 439 229 0 205 /**
 * Recursively walks the scene graph beginning at the indicated node (which
 * need not be an AnimBundleNode), and returns the first AnimBundle found.
 * Returns NULL if no AnimBundle can be found.
 */ 1 4 root 1 454  
22 0 0 7 39 491 0 0 0 0 
23 0 0 7 47 442 240 0 148 /**
 * Creates the PartGroup, and adds it to the indicated parent.  The only way
 * to delete it subsequently is to delete the entire hierarchy.
 */ 2 6 parent 1 442  4 name 1 484  
24 0 0 6 49 471 0 0 156 /**
 * Returns true if this part is a CharacterJoint, false otherwise.  This is a
 * tiny optimization over is_of_type(CharacterType::get_class_type()).
 */ 1 4 this 3 499  
25 0 0 7 50 442 240 0 110 /**
 * Allocates and returns a new copy of the node.  Children are not copied, but
 * see copy_subgraph().
 */ 1 4 this 3 499  
26 0 0 7 51 442 240 0 84 /**
 * Allocates and returns a new copy of this node and of all of its children.
 */ 1 4 this 3 499  
27 0 0 6 52 436 0 0 58 /**
 * Returns the number of child nodes of the group.
 */ 1 4 this 3 499  
28 0 0 7 53 442 240 0 46 /**
 * Returns the nth child of the group.
 */ 2 4 this 3 499  1 n 1 436  
29 0 0 7 55 442 240 0 250 /**
 * Returns the first child found with the indicated name, or NULL if no such
 * child exists.  This method searches only the children of this particular
 * PartGroup; it does not recursively search the entire graph.  See also
 * find_child().
 */ 2 4 this 3 499  4 name 1 484  
30 0 0 7 56 442 240 0 210 /**
 * Returns the first descendant found with the indicated name, or NULL if no
 * such descendant exists.  This method searches the entire graph beginning at
 * this PartGroup; see also get_child_named().
 */ 2 4 this 3 499  4 name 1 484  
31 0 0 4 57 487 0 0 262 /**
 * Sorts the children nodes at each level of the hierarchy into alphabetical
 * order.  This should be done after creating the hierarchy, to guarantee that
 * the correct names will match up together when the AnimBundle is later bound
 * to a PlayerRoot.
 */ 1 4 this 3 442  
32 0 0 6 60 471 0 0 287 /**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */ 2 4 this 3 442  9 transform 1 501  
33 0 0 6 61 471 0 0 287 /**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */ 4 4 this 3 442  3 pos 1 504  3 hpr 1 504  5 scale 1 504  
34 0 0 6 62 471 0 0 287 /**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */ 2 4 this 3 442  5 value 1 460  
35 0 0 6 63 471 0 0 311 /**
 * Specifies a node to influence this particular joint so that it will always
 * hold the node's transform.  Returns true if this is a joint that can be so
 * controlled, false otherwise.
 *
 * This is normally only called internally by PartBundle::control_joint(), but
 * you may also call it directly.
 */ 2 4 this 3 442  4 node 1 454  
36 0 0 6 64 471 0 0 261 /**
 * Undoes the effect of a previous call to apply_freeze() or apply_control().
 * Returns true if the joint was modified, false otherwise.
 *
 * This is normally only called internally by PartBundle::release_joint(), but
 * you may also call it directly.
 */ 1 4 this 3 442  
37 0 0 7 65 508 280 0 181 /**
 * Returns the AnimChannelBase that has been forced to this joint by a
 * previous call to apply_freeze() or apply_control(), or NULL if no such
 * channel has been applied.
 */ 1 4 this 3 499  
38 0 0 4 66 487 0 0 78 /**
 * Writes a brief description of the group and all of its descendants.
 */ 3 4 this 3 499  3 out 1 488  12 indent_level 1 436  
39 0 0 4 67 487 0 0 117 /**
 * Writes a brief description of the group, showing its current value, and
 * that of all of its descendants.
 */ 3 4 this 3 499  3 out 1 488  12 indent_level 1 436  
40 0 0 7 68 491 0 0 0 0 
41 0 0 7 42 492 0 0 0 1 4 this 3 442  
42 0 0 6 44 493 0 0 0 1 4 this 3 442  
43 0 0 6 79 471 0 0 286 /**
 * Returns true if the AnimControl is being bound asynchronously, and has not
 * yet finished.  If this is true, the AnimControl's interface is still
 * available and will be perfectly useful (though get_anim() might return
 * NULL), but nothing visible will happen immediately.
 */ 1 4 this 3 509  
44 0 0 4 80 487 0 0 102 /**
 * Blocks the current thread until the AnimControl has finished loading and is
 * fully bound.
 */ 1 4 this 3 511  
45 0 0 6 81 471 0 0 154 /**
 * Returns true if the AnimControl was successfully loaded, or false if there
 * was a problem.  This may return false while is_pending() is true.
 */ 1 4 this 3 509  
46 0 0 4 82 487 0 0 205 /**
 * Specifies an event name that will be thrown when the AnimControl is
 * finished binding asynchronously.  If the AnimControl has already finished
 * binding, the event will be thrown immediately.
 */ 2 4 this 3 511  10 done_event 1 484  
47 0 0 6 83 484 0 0 113 /**
 * Returns the event name that will be thrown when the AnimControl is finished
 * binding asynchronously.
 */ 1 4 this 3 509  
48 0 0 7 84 475 414 0 65 /**
 * Returns the PartBundle bound in with this AnimControl.
 */ 1 4 this 3 509  
49 0 0 7 85 439 229 0 65 /**
 * Returns the AnimBundle bound in with this AnimControl.
 */ 1 4 this 3 509  
50 0 0 6 86 436 0 0 358 /**
 * Returns the particular channel index associated with this AnimControl.
 * This channel index is the slot on which each AnimGroup is bound to its
 * associated PartGroup, for each joint in the animation.
 *
 * It will be true that
 * get_part()->find_child("n")->get_bound(get_channel_index()) ==
 * get_anim()->find_child("n"), for each joint "n".
 */ 1 4 this 3 509  
51 0 0 6 87 512 0 0 369 /**
 * Returns the subset of joints controlled by this AnimControl.  Most of the
 * time, this will be BitArray::all_on(), for a normal full-body animation.
 * For a subset animation, however, this will be just a subset of those bits,
 * corresponding to the set of joints and sliders actually bound (as
 * enumerated by bind_hierarchy() in depth-first LIFO order).
 */ 1 4 this 3 509  
52 0 0 4 88 487 0 0 515 /**
 * Associates the indicated PandaNode with the AnimControl.  By convention,
 * this node represents the root node of the model file that corresponds to
 * this AnimControl's animation file, though nothing in this code makes this
 * assumption or indeed does anything with this node.
 *
 * The purpose of this is simply to allow the AnimControl to keep a reference
 * count on the ModelRoot node that generated it, so that the model will not
 * disappear from the model pool until it is no longer referenced.
 */ 2 4 this 3 511  5 model 1 454  
53 0 0 7 89 454 0 0 81 /**
 * Retrieves the pointer set via set_anim_model().  See set_anim_model().
 */ 1 4 this 3 509  
54 0 0 4 90 487 0 0 10 /**
 *
 */ 2 4 this 3 509  3 out 1 488  
55 0 0 7 91 491 0 0 0 0 
56 0 0 7 71 515 0 0 0 1 4 this 3 511  
57 0 0 6 74 516 0 0 0 1 4 this 3 511  
58 0 0 6 76 493 0 0 0 1 4 this 3 511  
59 0 0 7 93 491 0 0 0 1 4 this 3 517  
60 0 0 7 94 491 0 0 0 0 
61 0 0 4 99 487 0 0 0 3 4 this 3 519  5 frame 1 436  5 value 1 520  
62 0 0 4 100 487 0 0 72 // These transform-component methods only have meaning for matrix types. 3 4 this 3 519  5 frame 1 436  5 value 1 520  
63 0 0 4 101 487 0 0 0 3 4 this 3 519  5 frame 1 436  5 scale 1 521  
64 0 0 4 102 487 0 0 0 3 4 this 3 519  5 frame 1 436  3 hpr 1 521  
65 0 0 4 103 487 0 0 0 3 4 this 3 519  5 frame 1 436  4 quat 1 522  
66 0 0 4 104 487 0 0 0 3 4 this 3 519  5 frame 1 436  3 pos 1 521  
67 0 0 4 105 487 0 0 0 3 4 this 3 519  5 frame 1 436  5 shear 1 521  
68 0 0 7 106 491 0 0 0 1 4 this 3 525  
69 0 0 7 107 491 0 0 0 0 
70 0 0 4 112 487 0 0 0 3 4 this 3 527  5 frame 1 436  5 scale 1 521  
71 0 0 4 113 487 0 0 0 3 4 this 3 527  5 frame 1 436  3 hpr 1 521  
72 0 0 4 114 487 0 0 0 3 4 this 3 527  5 frame 1 436  4 quat 1 522  
73 0 0 4 115 487 0 0 0 3 4 this 3 527  5 frame 1 436  3 pos 1 521  
74 0 0 4 116 487 0 0 0 3 4 this 3 527  5 frame 1 436  5 shear 1 521  
75 0 0 7 117 491 0 0 0 1 4 this 3 528  
76 0 0 7 118 491 0 0 0 0 
77 0 0 4 121 487 0 0 44 /**
 * Explicitly sets the matrix value.
 */ 2 4 this 3 530  5 value 1 531  
78 0 0 4 121 487 0 0 107 /**
 * Explicitly sets the matrix value, using the indicated TransformState object
 * as a convenience.
 */ 2 4 this 3 530  5 value 1 501  
79 0 0 4 122 487 0 0 124 /**
 * Specifies a node whose transform will be queried each frame to implicitly
 * specify the transform of this joint.
 */ 2 4 this 3 530  4 node 1 454  
80 0 0 7 123 501 0 0 93 /**
 * Returns the explicit TransformState value that was set via set_value(), if
 * any.
 */ 1 4 this 3 532  
81 0 0 7 124 454 0 0 70 /**
 * Returns the node that was set via set_value_node(), if any.
 */ 1 4 this 3 532  
82 0 0 7 127 491 0 0 0 0 
83 0 0 7 130 534 280 0 10 /**
 *
 */ 2 6 parent 1 433  4 name 1 484  
84 0 0 6 131 471 0 0 80 /**
 * Returns true if the given letter is one of the nine valid table id's.
 */ 1 8 table_id 1 535  
85 0 0 4 132 487 0 0 255 /**
 * Assigns the indicated table.  table_id is one of 'i', 'j', 'k', for scale,
 * 'a', 'b', 'c' for shear, 'h', 'p', 'r', for rotation, and 'x', 'y', 'z',
 * for translation.  The new table must have either zero, one, or
 * get_num_frames() frames.
 */ 3 4 this 3 534  8 table_id 1 535  5 table 1 536  
86 0 0 7 133 540 0 0 103 /**
 * Returns a pointer to the indicated subtable's data, if it exists, or NULL
 * if it does not.
 */ 2 4 this 3 538  8 table_id 1 535  
87 0 0 4 134 487 0 0 90 /**
 * Removes all the tables from the channel, and resets it to its initial
 * state.
 */ 1 4 this 3 534  
88 0 0 6 135 471 0 0 68 /**
 * Returns true if the indicated subtable has been assigned.
 */ 2 4 this 3 538  8 table_id 1 535  
89 0 0 4 136 487 0 0 59 /**
 * Removes the indicated table from the definition.
 */ 2 4 this 3 534  8 table_id 1 535  
90 0 0 7 141 491 0 0 0 0 
91 0 0 4 143 487 0 0 98 /**
 * Explicitly sets the value.  This will remove any node assigned via
 * set_value_node().
 */ 2 4 this 3 541  5 value 1 460  
92 0 0 4 144 487 0 0 178 /**
 * Specifies a node whose transform will be queried each frame to implicitly
 * specify the transform of this joint.  This will override the values set by
 * set_value().
 */ 2 4 this 3 541  4 node 1 454  
93 0 0 7 151 491 0 0 0 0 
94 0 0 4 154 487 0 0 34 /**
 * Assigns the data table.
 */ 2 4 this 3 542  5 table 1 536  
95 0 0 7 155 540 0 0 90 /**
 * Returns a pointer to the table's data, if it exists, or NULL if it does
 * not.
 */ 1 4 this 3 543  
96 0 0 6 156 471 0 0 60 /**
 * Returns true if the data table has been assigned.
 */ 1 4 this 3 543  
97 0 0 4 157 487 0 0 34 /**
 * Empties the data table.
 */ 1 4 this 3 542  
98 0 0 7 159 491 0 0 0 0 
99 0 0 7 162 545 326 0 117 /**
 * Returns the AnimControl associated with the given name, or NULL if no such
 * control has been associated.
 */ 0 
100 0 0 7 162 545 326 0 0 1 6 param0 0 546  
101 0 0 4 164 487 0 0 247 /**
 * Associates the given AnimControl with this collection under the given name.
 * The AnimControl will remain associated until a new AnimControl is
 * associated with the same name later, or until unbind_anim() is called with
 * this name.
 */ 3 4 this 3 545  7 control 1 511  4 name 1 484  
102 0 0 7 165 511 264 0 117 /**
 * Returns the AnimControl associated with the given name, or NULL if no such
 * control has been associated.
 */ 2 4 this 3 546  4 name 1 484  
103 0 0 6 166 471 0 0 184 /**
 * Removes the AnimControl associated with the given name, if any.  Returns
 * true if an AnimControl was removed, false if there was no AnimControl with
 * the indicated name.
 */ 2 4 this 3 545  4 name 1 484  
104 0 0 6 167 436 0 0 78 /**
 * Returns the number of AnimControls associated with this collection.
 */ 1 4 this 3 546  
105 0 0 7 168 511 264 0 71 /**
 * Returns the nth AnimControl associated with this collection.
 */ 2 4 this 3 546  1 n 1 436  
106 0 0 6 169 484 0 0 83 /**
 * Returns the name of the nth AnimControl associated with this collection.
 */ 2 4 this 3 546  1 n 1 436  
107 0 0 4 172 487 0 0 56 /**
 * Disassociates all anims from this collection.
 */ 1 4 this 3 545  
108 0 0 6 173 471 0 0 46 /**
 * Starts the named animation playing.
 */ 2 4 this 3 545  9 anim_name 1 484  
109 0 0 6 173 471 0 0 46 /**
 * Starts the named animation playing.
 */ 4 4 this 3 545  9 anim_name 1 484  4 from 1 435  2 to 1 435  
110 0 0 6 174 471 0 0 46 /**
 * Starts the named animation looping.
 */ 3 4 this 3 545  9 anim_name 1 484  7 restart 1 471  
111 0 0 6 174 471 0 0 46 /**
 * Starts the named animation looping.
 */ 5 4 this 3 545  9 anim_name 1 484  7 restart 1 471  4 from 1 435  2 to 1 435  
112 0 0 6 175 471 0 0 37 /**
 * Stops the named animation.
 */ 2 4 this 3 545  9 anim_name 1 484  
113 0 0 6 176 471 0 0 61 /**
 * Sets to a particular frame in the named animation.
 */ 3 4 this 3 545  9 anim_name 1 484  5 frame 1 435  
114 0 0 4 177 487 0 0 48 // These functions operate on all anims at once. 1 4 this 3 545  
115 0 0 4 177 487 0 0 41 /**
 * Starts all animations playing.
 */ 3 4 this 3 545  4 from 1 435  2 to 1 435  
116 0 0 4 178 487 0 0 41 /**
 * Starts all animations looping.
 */ 2 4 this 3 545  7 restart 1 471  
117 0 0 4 178 487 0 0 41 /**
 * Starts all animations looping.
 */ 4 4 this 3 545  7 restart 1 471  4 from 1 435  2 to 1 435  
118 0 0 6 179 471 0 0 127 /**
 * Stops all currently playing animations.  Returns true if any animations
 * were stopped, false if none were playing.
 */ 1 4 this 3 545  
119 0 0 4 180 487 0 0 54 /**
 * Sets all animations to the indicated frame.
 */ 2 4 this 3 545  5 frame 1 435  
120 0 0 6 181 436 0 0 67 /**
 * Returns the current frame in the last-started animation.
 */ 1 4 this 3 546  
121 0 0 6 181 436 0 0 99 /**
 * Returns the current frame in the named animation, or 0 if the animation is
 * not found.
 */ 2 4 this 3 546  9 anim_name 1 484  
122 0 0 6 182 436 0 0 76 /**
 * Returns the total number of frames in the last-started animation.
 */ 1 4 this 3 546  
123 0 0 6 182 436 0 0 108 /**
 * Returns the total number of frames in the named animation, or 0 if the
 * animation is not found.
 */ 2 4 this 3 546  9 anim_name 1 484  
124 0 0 6 183 471 0 0 95 /**
 * Returns true if the last-started animation is currently playing, false
 * otherwise.
 */ 1 4 this 3 546  
125 0 0 6 183 471 0 0 85 /**
 * Returns true if the named animation is currently playing, false otherwise.
 */ 2 4 this 3 546  9 anim_name 1 484  
126 0 0 6 184 484 0 0 183 /**
 * Returns the name of the bound AnimControl currently playing, if any.  If
 * more than one AnimControl is currently playing, returns all of the names
 * separated by spaces.
 */ 1 4 this 3 546  
127 0 0 4 185 487 0 0 10 /**
 *
 */ 2 4 this 3 546  3 out 1 488  
128 0 0 4 186 487 0 0 10 /**
 *
 */ 2 4 this 3 546  3 out 1 488  
129 0 0 7 189 548 0 0 10 /**
 *
 */ 0 
130 0 0 6 190 436 0 0 64 /**
 * Returns the number of animation records in the table.
 */ 1 4 this 3 549  
131 0 0 6 191 436 0 0 321 /**
 * Returns the index number in the table of the animation record with the
 * indicated name, or -1 if the name is not present.  By convention, the
 * basename is the filename of the egg or bam file, without the directory part
 * and without the extension.  That is, it is
 * Filename::get_basename_wo_extension().
 */ 2 4 this 3 549  8 basename 1 484  
132 0 0 6 192 484 0 0 86 /**
 * Returns the basename stored for the nth animation record.  See find_anim().
 */ 2 4 this 3 549  1 n 1 436  
133 0 0 6 193 460 0 0 70 /**
 * Returns the frame rate stored for the nth animation record.
 */ 2 4 this 3 549  1 n 1 436  
134 0 0 6 194 436 0 0 76 /**
 * Returns the number of frames stored for the nth animation record.
 */ 2 4 this 3 549  1 n 1 436  
135 0 0 4 195 487 0 0 56 /**
 * Removes all animation records from the table.
 */ 1 4 this 3 548  
136 0 0 4 196 487 0 0 113 /**
 * Removes the nth animation records from the table.  This renumbers indexes
 * for following animations.
 */ 2 4 this 3 548  1 n 1 436  
137 0 0 4 197 487 0 0 227 /**
 * Adds a new animation record to the table.  If there is already a record of
 * this name, no operation is performed (the original record is unchanged).
 * See find_anim().  This will invalidate existing index numbers.
 */ 4 4 this 3 548  8 basename 1 484  15 base_frame_rate 1 460  10 num_frames 1 436  
138 0 0 4 198 487 0 0 160 /**
 * Copies the animation records from the other table into this one.  If a
 * given record name exists in both tables, the record in this one supercedes.
 */ 2 4 this 3 548  5 other 1 549  
139 0 0 4 199 487 0 0 10 /**
 *
 */ 2 4 this 3 549  3 out 1 488  
140 0 0 4 200 487 0 0 10 /**
 *
 */ 3 4 this 3 549  3 out 1 488  12 indent_level 1 436  
141 0 0 7 201 491 0 0 0 0 
142 0 0 7 204 551 371 0 10 /**
 *
 */ 0 
143 0 0 7 204 551 371 0 10 /**
 *
 */ 1 4 copy 1 552  
144 0 0 6 205 551 0 0 0 2 4 this 3 551  4 copy 1 552  
145 0 0 4 206 487 0 0 342 /**
 * Adds the named joint to the list of joints that will be explicitly included
 * in the subset.  Any joint at or below a named node will be included in the
 * subset (unless a lower node is also listed in the exclude list).
 *
 * Since the name is a GlobPattern, it may of course include filename globbing
 * characters like * and ?.
 */ 2 4 this 3 551  4 name 1 554  
146 0 0 4 207 487 0 0 352 /**
 * Adds the named joint to the list of joints that will be explicitly
 * exlcluded from the subset.  Any joint at or below a named node will not be
 * included in the subset (unless a lower node is also listed in the include
 * list).
 *
 * Since the name is a GlobPattern, it may of course include filename globbing
 * characters like * and ?.
 */ 2 4 this 3 551  4 name 1 554  
147 0 0 4 208 487 0 0 98 /**
 * Appends the include and exclude list from the other object onto this
 * object's lists.
 */ 2 4 this 3 551  5 other 1 552  
148 0 0 4 209 487 0 0 10 /**
 *
 */ 2 4 this 3 552  3 out 1 488  
149 0 0 6 210 471 0 0 147 /**
 * Returns true if the include list is completely empty, false otherwise.  If
 * it is empty, it is the same thing as including all joints.
 */ 1 4 this 3 552  
150 0 0 6 211 471 0 0 101 /**
 * Returns true if the indicated name matches a name on the include list,
 * false otherwise.
 */ 2 4 this 3 552  10 joint_name 1 484  
151 0 0 6 212 471 0 0 101 /**
 * Returns true if the indicated name matches a name on the exclude list,
 * false otherwise.
 */ 2 4 this 3 552  10 joint_name 1 484  
152 0 0 7 216 559 374 0 0 1 6 param0 0 557  
153 0 0 7 216 559 374 0 10 /**
 *
 */ 7 4 name 1 484  8 filename 1 560  7 options 1 563  6 loader 1 566  7 control 1 511  21 hierarchy_match_flags 1 436  6 subset 1 552  
154 0 0 7 217 491 0 0 0 0 
155 0 0 7 220 475 414 0 133 /**
 * Normally, a PartBundle constructor should not be called directly--it will
 * get created when a PartBundleNode is created.
 */ 1 4 name 1 484  
156 0 0 7 221 549 0 0 181 /**
 * Returns the AnimPreloadTable associated with the PartBundle.  This table,
 * if present, can be used for the benefit of load_bind_anim() to allow
 * asynchronous binding.
 */ 1 4 this 3 568  
157 0 0 7 222 548 0 0 106 /**
 * Returns a modifiable pointer to the AnimPreloadTable associated with the
 * PartBundle, if any.
 */ 1 4 this 3 475  
158 0 0 4 223 487 0 0 72 /**
 * Replaces the AnimPreloadTable associated with the PartBundle.
 */ 2 4 this 3 475  5 table 1 548  
159 0 0 4 224 487 0 0 71 /**
 * Removes any AnimPreloadTable associated with the PartBundle.
 */ 1 4 this 3 475  
160 0 0 4 225 487 0 0 85 /**
 * Copies the contents of the other PartBundle's preload table into this one.
 */ 2 4 this 3 475  5 other 1 568  
161 0 0 4 227 487 0 0 270 /**
 * Defines the algorithm that is used when blending multiple frames or
 * multiple animations together, when either anim_blend_flag or
 * frame_blend_flag is set to true.
 *
 * See partBundle.h for a description of the meaning of each of the BlendType
 * values.
 */ 2 4 this 3 475  2 bt 1 470  
162 0 0 6 228 470 0 0 178 /**
 * Returns the algorithm that is used when blending multiple frames or
 * multiple animations together, when either anim_blend_flag or
 * frame_blend_flag is set to true.
 */ 1 4 this 3 568  
163 0 0 4 229 487 0 0 581 /**
 * Defines the way the character responds to multiple calls to
 * set_control_effect()).  By default, this flag is set false, which disallows
 * multiple animations.  When this flag is false, it is not necessary to
 * explicitly set the control_effect when starting an animation; starting the
 * animation will implicitly remove the control_effect from the previous
 * animation and set it on the current one.
 *
 * However, if this flag is set true, the control_effect must be explicitly
 * set via set_control_effect() whenever an animation is to affect the
 * character.
 */ 2 4 this 3 475  15 anim_blend_flag 1 471  
164 0 0 6 230 471 0 0 136 /**
 * Returns whether the character allows multiple different animations to be
 * bound simultaneously.  See set_anim_blend_flag().
 */ 1 4 this 3 568  
165 0 0 4 231 487 0 0 775 /**
 * Specifies whether the character interpolates (blends) between two
 * sequential frames of an active animation, showing a smooth intra-frame
 * motion, or whether it holds each frame until the next frame is ready,
 * showing precisely the specified animation.
 *
 * When this value is false, the character holds each frame until the next is
 * ready.  When this is true, the character will interpolate between two
 * consecutive frames of animation for each frame the animation is onscreen,
 * according to the amount of time elapsed between the frames.
 *
 * The default value of this flag is determined by the interpolate-frames
 * Config.prc variable.
 *
 * Use set_blend_type() to change the algorithm that the character uses to
 * interpolate matrix positions.
 */ 2 4 this 3 475  16 frame_blend_flag 1 471  
166 0 0 6 232 471 0 0 205 /**
 * Returns whether the character interpolates (blends) between two sequential
 * animation frames, or whether it holds the current frame until the next one
 * is ready.  See set_frame_blend_flag().
 */ 1 4 this 3 568  
167 0 0 4 233 487 0 0 111 /**
 * Specifies the transform matrix which is implicitly applied at the root of
 * the animated hierarchy.
 */ 2 4 this 3 475  10 root_xform 1 531  
168 0 0 4 234 487 0 0 81 /**
 * Applies the indicated transform to the root of the animated hierarchy.
 */ 2 4 this 3 475  3 mat 1 531  
169 0 0 6 235 531 0 0 109 /**
 * Returns the transform matrix which is implicitly applied at the root of the
 * animated hierarchy.
 */ 1 4 this 3 568  
170 0 0 7 236 475 414 0 226 /**
 * Returns a PartBundle that is a duplicate of this one, but with the
 * indicated transform applied.  If this is called multiple times with the
 * same TransformState pointer, it returns the same PartBundle each time.
 */ 2 4 this 3 475  9 transform 1 501  
171 0 0 6 237 436 0 0 94 /**
 * Returns the number of PartBundleNodes that contain a pointer to this
 * PartBundle.
 */ 1 4 this 3 568  
172 0 0 7 238 473 0 0 74 /**
 * Returns the nth PartBundleNode associated with this PartBundle.
 */ 2 4 this 3 568  1 n 1 436  
173 0 0 4 266 487 0 0 518 /**
 * Sets the control effect of all AnimControls to zero (but does not "stop"
 * the AnimControls).  The character will no longer be affected by any
 * animation, and will return to its default pose (unless restore-initial-pose
 * is false).
 *
 * The AnimControls which are no longer associated will not be using any CPU
 * cycles, but they may still be in the "playing" state; if they are later
 * reassociated with the PartBundle they will resume at their current frame as
 * if they'd been running all along.
 */ 1 4 this 3 475  
174 0 0 4 267 487 0 0 530 /**
 * Sets the amount by which the character is affected by the indicated
 * AnimControl (and its associated animation).  Normally, this will only be
 * zero or one.  Zero indicates the animation does not affect the character,
 * and one means it does.
 *
 * If the _anim_blend_flag is not false (see set_anim_blend_flag()), it is
 * possible to have multiple AnimControls in effect simultaneously.  In this
 * case, the effect is a weight that indicates the relative importance of each
 * AnimControl to the final animation.
 */ 3 4 this 3 475  7 control 1 511  6 effect 1 460  
175 0 0 6 268 460 0 0 153 /**
 * Returns the amount by which the character is affected by the indicated
 * AnimControl and its associated animation.  See set_control_effect().
 */ 2 4 this 3 568  7 control 1 511  
176 0 0 4 269 487 0 0 55 /**
 * Writes a one-line description of the bundle.
 */ 2 4 this 3 568  3 out 1 488  
177 0 0 7 270 511 264 0 790 /**
 * Binds the animation to the bundle, if possible, and returns a new
 * AnimControl that can be used to start and stop the animation.  If the anim
 * hierarchy does not match the part hierarchy, returns NULL.
 *
 * If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,
 * it may contain a union of PartGroup::HierarchyMatchFlags values indicating
 * conditions that will be tolerated (but warnings will still be issued).
 *
 * If subset is specified, it restricts the binding only to the named subtree
 * of joints.
 *
 * The AnimControl is not stored within the PartBundle; it is the user's
 * responsibility to maintain the pointer.  The animation will automatically
 * unbind itself when the AnimControl destructs (i.e.  its reference count
 * goes to zero).
 */ 4 4 this 3 475  4 anim 1 439  21 hierarchy_match_flags 1 436  6 subset 1 552  
178 0 0 7 271 511 264 0 1088 /**
 * Binds an animation to the bundle.  The animation is loaded from the disk
 * via the indicated Loader object.  In other respects, this behaves similarly
 * to bind_anim(), with the addition of asynchronous support.
 *
 * If allow_aysnc is true, the load will be asynchronous if possible.  This
 * requires that the animation basename can be found in the PartBundle's
 * preload table (see get_anim_preload()).
 *
 * In an asynchronous load, the animation file will be loaded and bound in a
 * sub-thread.  This means that the animation will not necessarily be
 * available at the time this method returns.  You may still use the returned
 * AnimControl immediately, though, but no visible effect will occur until the
 * animation eventually becomes available.
 *
 * You can test AnimControl::is_pending() to see if the animation has been
 * loaded yet, or wait for it to finish with AnimControl::wait_pending() or
 * even PartBundle::wait_pending().  You can also set an event to be triggered
 * when the animation finishes loading with
 * AnimControl::set_pending_done_event().
 */ 6 4 this 3 475  6 loader 1 566  8 filename 1 560  21 hierarchy_match_flags 1 436  6 subset 1 552  11 allow_async 1 471  
179 0 0 4 272 487 0 0 153 /**
 * Blocks the current thread until all currently-pending AnimControls, with a
 * nonzero control effect, have been loaded and are properly bound.
 */ 1 4 this 3 475  
180 0 0 6 273 471 0 0 373 /**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */ 5 4 this 3 475  10 joint_name 1 484  3 pos 1 504  3 hpr 1 504  5 scale 1 504  
181 0 0 6 273 471 0 0 373 /**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */ 3 4 this 3 475  10 joint_name 1 484  5 value 1 460  
182 0 0 6 273 471 0 0 373 /**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */ 3 4 this 3 475  10 joint_name 1 484  9 transform 1 501  
183 0 0 6 274 471 0 0 396 /**
 * Specifies that the joint with the indicated name should be animated with
 * the transform on the indicated node.  It will henceforth always follow the
 * node's transform, regardless of any animations that may subsequently be
 * bound to the joint.
 *
 * Returns true if the joint is successfully controlled, or false if the named
 * child is not a joint (or slider) or does not exist.
 */ 3 4 this 3 475  10 joint_name 1 484  4 node 1 454  
184 0 0 6 275 471 0 0 342 /**
 * Releases the named joint from the effects of a previous call to
 * freeze_joint() or control_joint(). It will henceforth once again follow
 * whatever transforms are dictated by the animation.
 *
 * Returns true if the joint is released, or false if the named child was not
 * previously controlled or frozen, or it does not exist.
 */ 2 4 this 3 475  10 joint_name 1 484  
185 0 0 6 276 471 0 0 216 /**
 * Updates all the parts in the bundle to reflect the data for the current
 * frame (as set in each of the AnimControls).
 *
 * Returns true if any part has changed as a result of this, or false
 * otherwise.
 */ 1 4 this 3 475  
186 0 0 6 277 471 0 0 131 /**
 * Updates all the parts in the bundle to reflect the data for the current
 * frame, whether we believe it needs it or not.
 */ 1 4 this 3 475  
187 0 0 7 278 491 0 0 0 0 
188 0 0 7 249 473 0 0 226 /**
 * The PartBundle and its node should be constructed together.  Generally, the
 * derived classes of PartBundleNode will automatically create a PartBundle of
 * the appropriate type, and pass it up to this constructor.
 */ 2 4 name 1 484  6 bundle 1 475  
189 0 0 6 250 436 0 0 10 /**
 *
 */ 1 4 this 3 570  
190 0 0 7 251 475 414 0 10 /**
 *
 */ 2 4 this 3 570  1 n 1 436  
191 0 0 7 253 476 0 0 204 /**
 * Returns the PartBundleHandle that wraps around the actual nth PartBundle.
 * While the PartBundle pointer might later change due to a future flatten
 * operation, the PartBundleHandle will not.
 */ 2 4 this 3 570  1 n 1 436  
192 0 0 7 265 491 0 0 0 0 
193 0 0 7 261 476 0 0 10 /**
 *
 */ 1 6 bundle 1 475  
194 0 0 7 261 476 0 0 0 1 6 param0 0 572  
195 0 0 7 262 475 414 0 68 /**
 * Returns the actual PartBundle embedded within the handle.
 */ 1 4 this 3 476  
196 0 0 4 263 487 0 0 68 /**
 * Changes the actual PartBundle embedded within the handle.
 */ 2 4 this 3 476  6 bundle 1 475  
197 0 0 6 281 436 0 0 310 /**
 * Returns the number of channels that might be bound to this PartGroup.  This
 * might not be the actual number of channels, since there might be holes in
 * the list; it is one more than the index number of the highest bound
 * channel.  Thus, it is called get_max_bound() instead of get_num_bound().
 */ 1 4 this 3 574  
198 0 0 7 282 508 280 0 371 /**
 * Returns the nth bound channel on this PartGroup.  n can be determined by
 * iterating from 0 to one less than get_max_bound(); or n might be
 * AnimControl::get_channel_index().
 *
 * This will return NULL if there is no channel bound on the indicated index.
 * It is an error to call this if n is less than zero or greater than or equal
 * to get_max_bound().
 */ 2 4 this 3 574  1 n 1 436  
199 0 0 4 283 487 0 0 0 2 4 this 3 574  3 out 1 488  
200 0 0 7 284 491 0 0 0 0 
201 0 0 7 292 491 0 0 0 0 
202 0 0 7 288 491 0 0 0 0 
203 0 0 7 289 520 0 0 0 1 4 this 3 576  
204 0 0 7 290 520 0 0 0 1 4 this 3 576  
205 0 0 7 299 491 0 0 0 0 
206 0 0 7 295 491 0 0 0 0 
207 0 0 6 296 460 0 0 0 1 4 this 3 578  
208 0 0 6 297 460 0 0 0 1 4 this 3 578  
209 0 0 4 202 487 0 0 0 3 9 root_node 1 454  8 controls 1 545  21 hierarchy_match_flags 1 436  
150
430 9 AnimGroup 0 26625 9 AnimGroup 9 AnimGroup 0 0 0 1 214 215 1 580 8 216 217 218 219 220 221 222 223 1 598 0 2 3 431 210 211 3 432 212 213 0 0 165
/**
 * This is the base class for AnimChannel and AnimBundle.  It implements a
 * hierarchy of AnimChannels.  The root of the hierarchy must be an
 * AnimBundle.
 */

431 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

432 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

433 11 AnimGroup * 0 8576 11 AnimGroup * 11 AnimGroup * 0 0 430 0 0 0 0 0 0 0 0 0 0

434 10 AnimBundle 0 141313 10 AnimBundle 10 AnimBundle 0 0 0 1 224 229 2 581 582 4 225 226 227 228 0 0 1 0 430 0 0 0 0 169
/**
 * This is the root of an AnimChannel hierarchy.  It knows the frame rate and
 * number of frames of all the channels in the hierarchy (which must all
 * match).
 */

435 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

436 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

437 14 AnimBundleNode 0 141313 14 AnimBundleNode 14 AnimBundleNode 0 0 0 1 230 234 1 583 3 231 232 233 0 0 1 0 438 0 0 0 0 169
/**
 * This is a node that contains a pointer to an AnimBundle.  Like
 * PartBundleNode, it exists solely to make it easy to store AnimBundles in
 * the scene graph.
 */

438 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175
/**
 * A basic node of the scene graph or data graph.  This is the base class of
 * all specialized nodes, and also serves as a generic node with no special
 * properties.
 */

439 12 AnimBundle * 0 8576 12 AnimBundle * 12 AnimBundle * 0 0 434 0 0 0 0 0 0 0 0 0 0

440 9 PartGroup 0 26625 9 PartGroup 9 PartGroup 0 0 0 1 239 240 1 584 17 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 1 599 0 2 3 431 235 236 3 432 237 238 0 1 441 105
/**
 * This is the base class for PartRoot and MovingPart.  It defines a hierarchy
 * of MovingParts.
 */

441 19 HierarchyMatchFlags 0 794624 30 PartGroup::HierarchyMatchFlags 30 PartGroup::HierarchyMatchFlags 440 0 0 0 0 0 0 0 0 0 3 17 HMF_ok_part_extra 28 PartGroup::HMF_ok_part_extra 0
1 17 HMF_ok_anim_extra 28 PartGroup::HMF_ok_anim_extra 0
2 22 HMF_ok_wrong_root_name 33 PartGroup::HMF_ok_wrong_root_name 0
4 0 214
// This enum defines bits which may be passed into check_hierarchy() and
// PartBundle::bind_anim() to allow an inexact match of channel hierarchies.
// This specifies conditions that we don't care about enforcing.

442 11 PartGroup * 0 8576 11 PartGroup * 11 PartGroup * 0 0 440 0 0 0 0 0 0 0 0 0 0

443 11 AnimControl 0 26625 11 AnimControl 11 AnimControl 0 0 0 0 264 0 13 265 266 267 268 269 270 271 272 273 274 275 276 277 0 0 3 3 444 258 259 3 445 260 261 3 432 262 263 0 0 255
/**
 * Controls the timing of a character animation.  An AnimControl object is
 * created for each character/bundle binding and manages the state of the
 * animation: whether started, stopped, or looping, and the current frame
 * number and play rate.
 */

444 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

445 13 AnimInterface 0 2048 13 AnimInterface 13 AnimInterface 0 0 0 0 0 0 0 0 0 0 0 0 226
/**
 * This is the fundamental interface for things that have a play/loop/stop
 * type interface for frame-based animation, such as animated characters.
 * This is the base class for AnimControl and other, similar classes.
 */

446 15 AnimChannelBase 0 141313 15 AnimChannelBase 15 AnimChannelBase 0 0 0 0 280 0 2 278 279 0 0 1 0 430 0 0 0 0 253
/**
 * Parent class for all animation channels.  An AnimChannel is an arbitrary
 * function that changes over time (actually, over frames), usually defined by
 * a table read from an egg file (but possibly computed or generated in any
 * other way).
 */

447 33 AnimChannel< ACMatrixSwitchType > 0 75777 33 AnimChannel< ACMatrixSwitchType > 33 AnimChannel< ACMatrixSwitchType > 0 0 0 0 280 0 9 281 282 283 284 285 286 287 288 289 0 0 1 0 446 0 0 0 1 448 0

448 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 449 0 0 0 0 0 0 0 0 0 0

449 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

450 17 AnimChannelMatrix 0 2105345 17 AnimChannelMatrix 17 AnimChannelMatrix 0 0 447 0 0 0 0 0 0 0 0 0 0

451 33 AnimChannel< ACScalarSwitchType > 0 75777 33 AnimChannel< ACScalarSwitchType > 33 AnimChannel< ACScalarSwitchType > 0 0 0 0 280 0 9 290 291 292 293 294 295 296 297 298 0 0 1 0 446 0 0 0 0 0

452 17 AnimChannelScalar 0 2105345 17 AnimChannelScalar 17 AnimChannelScalar 0 0 451 0 0 0 0 0 0 0 0 0 0

453 24 AnimChannelMatrixDynamic 0 141313 24 AnimChannelMatrixDynamic 24 AnimChannelMatrixDynamic 0 0 0 0 304 1 585 5 299 300 301 302 303 0 0 1 0 447 0 0 0 0 393
/**
 * An animation channel that accepts a matrix each frame from some dynamic
 * input provided by code.
 *
 * This object operates in two modes: in explicit mode, the programmer should
 * call set_value() each frame to indicate the new value; in implicit mode,
 * the programmer should call set_value_node() to indicate the node whose
 * transform will be copied to the joint each frame.
 */

454 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 438 0 0 0 0 0 0 0 0 0 0

455 25 AnimChannelMatrixXfmTable 0 75777 25 AnimChannelMatrixXfmTable 25 AnimChannelMatrixXfmTable 0 0 0 1 305 280 1 586 7 306 307 308 309 310 311 312 0 0 1 0 447 0 0 0 0 263
/**
 * An animation channel that issues a matrix each frame, read from a table
 * such as might have been read from an egg file.  The table actually consists
 * of nine sub-tables, each representing one component of the transform:
 * scale, rotate, translate.
 */

456 13 CPTA_stdfloat 0 2105344 13 CPTA_stdfloat 13 CPTA_stdfloat 0 0 457 0 0 0 0 0 0 0 0 0 0

457 10 CPTA_float 0 2105344 10 CPTA_float 10 CPTA_float 0 0 458 0 0 0 0 0 0 0 0 0 0

458 28 ConstPointerToArray< float > 0 2048 28 ConstPointerToArray< float > 28 ConstPointerToArray< float > 0 0 0 0 0 0 0 0 0 0 0 0 0

459 24 AnimChannelScalarDynamic 0 141313 24 AnimChannelScalarDynamic 24 AnimChannelScalarDynamic 0 0 0 0 318 2 587 588 3 313 314 317 0 0 1 0 451 0 0 0 0 396
/**
 * An animation channel that accepts a scalar each frame from some dynamic
 * input provided by code.
 *
 * This object operates in two modes: in explicit mode, the programmer should
 * call set_value() each frame to indicate the new value; in implicit mode,
 * the programmer should call set_value_node() to indicate the node whose X
 * component will be copied to the scalar each frame.
 */

460 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 461 0 0 0 0 0 0 0 0 0 0

461 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

462 22 AnimChannelScalarTable 0 141313 22 AnimChannelScalarTable 22 AnimChannelScalarTable 0 0 0 0 324 1 589 5 319 320 321 322 323 0 0 1 0 451 0 0 0 0 132
/**
 * An animation channel that issues a scalar each frame, read from a table
 * such as might have been read from an egg file.
 */

463 21 AnimControlCollection 0 26625 21 AnimControlCollection 21 AnimControlCollection 0 0 0 1 325 326 0 21 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 2 600 601 0 0 0 0 356
/**
 * This is a named collection of AnimControl pointers.  An AnimControl may be
 * added to the collection by name.  While an AnimControl is associated, its
 * reference count is maintained; associating a new AnimControl with the same
 * name will decrement the previous control's reference count (and possibly
 * delete it, unbinding its animation).
 */

464 16 AnimPreloadTable 0 75777 16 AnimPreloadTable 16 AnimPreloadTable 0 0 0 1 348 0 0 12 349 350 351 352 353 354 355 356 357 358 359 360 0 0 1 0 465 0 0 0 0 260
/**
 * This table records data about a list of animations for a particular model,
 * such as number of frames and frame rate.  It's used for implementating
 * asynchronous binding.
 *
 * This table is normally built by an offline tool, such as egg-optchar.
 */

465 17 CopyOnWriteObject 0 2048 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 0 0 0 0 0 0 0 0 169
/**
 * This base class provides basic reference counting, but also can be used
 * with a CopyOnWritePointer to provide get_read_pointer() and
 * get_write_pointer().
 */

466 10 PartSubset 0 141313 10 PartSubset 10 PartSubset 0 0 0 1 362 371 0 8 363 364 365 366 367 368 369 370 0 0 0 0 0 190
/**
 * This class is used to define a subset of part names to apply to the
 * PartBundle::bind_anim() operation.  Only those part names within the subset
 * will be included in the bind.
 */

467 15 BindAnimRequest 0 141313 15 BindAnimRequest 15 BindAnimRequest 0 0 0 1 372 374 0 1 373 0 0 1 0 468 0 0 0 0 136
/**
 * This class object manages an asynchronous load-and-bind animation request,
 * as issued through PartBundle::load_bind_anim().
 */

468 16 ModelLoadRequest 0 2048 16 ModelLoadRequest 16 ModelLoadRequest 0 0 0 0 0 0 0 0 0 0 0 0 191
/**
 * A class object that manages a single asynchronous model load request.
 * Create a new ModelLoadRequest, and add it to the loader via load_async(),
 * to begin an asynchronous load.
 */

469 10 PartBundle 0 141313 10 PartBundle 10 PartBundle 0 0 0 1 375 414 5 590 591 592 593 594 30 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 401 402 403 404 405 406 407 408 409 410 411 412 413 1 602 0 1 0 440 0 0 0 1 470 134
/**
 * This is the root of a MovingPart hierarchy.  It defines the hierarchy of
 * moving parts that make up an animatable object.
 */

470 9 BlendType 0 794624 21 PartBundle::BlendType 21 PartBundle::BlendType 469 0 0 0 0 0 0 0 0 0 4 9 BT_linear 21 PartBundle::BT_linear 387
// BT_linear does a componentwise average of all blended matrices, which
// is a linear blend.  The result of this is that if a particular vertex
// would have been at point P in one animation and point Q in another one,
// it will end up on the line in between them in the resulting blend
// animation.  However, this tends to stretch and squash limbs in strange
// and disturbing ways.
0 20 BT_normalized_linear 32 PartBundle::BT_normalized_linear 452
// BT_normalized_linear is a compromise on BT_linear.  The matrix is
// blended linearly without the scale and shear components, and the
// blended scale and shear components are applied separately.  This keeps
// all of the character's body parts in the correct size and shape.
// However, if the hierarchy is disconnected, body parts can fly off.
// It's essential the skeleton hierarchy be completely connected to use
// this blend mode successully.
1 16 BT_componentwise 28 PartBundle::BT_componentwise 115
// BT_componentwise linearly blends all components separately, including
// H, P, and R, and recomposes the matrix.
2 21 BT_componentwise_quat 33 PartBundle::BT_componentwise_quat 124
// BT_componentwise_quat linearly blends all components separately, except
// for rotation which is blended as a quaternion.
3 0 240
// This is the parameter to set_blend_type() and specifies the kind of
// blending operation to be performed when multiple controls are in effect
// simultaneously (see set_control_effect()) or between sequential frames of
// the animation.

471 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

472 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 448 0 0 0 0 0 0 0 0 0 0

473 16 PartBundleNode * 0 8576 16 PartBundleNode * 16 PartBundleNode * 0 0 474 0 0 0 0 0 0 0 0 0 0

474 14 PartBundleNode 0 75777 14 PartBundleNode 14 PartBundleNode 0 0 0 1 393 0 2 595 596 4 394 395 396 400 2 603 604 0 1 0 438 0 0 0 0 342
/**
 * This is a node that contains a pointer to an PartBundle.  Like
 * AnimBundleNode, it exists to make it easy to store PartBundles in the scene
 * graph.
 *
 * (Unlike AnimBundleNode, however, PartBundleNode has an additional function:
 * it is also the base class of the Character node type, which adds additional
 * functionality.)
 */

475 12 PartBundle * 0 8576 12 PartBundle * 12 PartBundle * 0 0 469 0 0 0 0 0 0 0 0 0 0

476 18 PartBundleHandle * 0 8576 18 PartBundleHandle * 18 PartBundleHandle * 0 0 477 0 0 0 0 0 0 0 0 0 0

477 16 PartBundleHandle 0 75777 16 PartBundleHandle 16 PartBundleHandle 0 0 0 1 397 0 1 597 2 398 399 0 0 1 0 478 0 0 0 0 546
/**
 * This is a trivial class returned by PartBundleNode::get_bundle().  Its
 * purpose is to hold the actual PartBundle pointer contained within the
 * PartBundleNode, so that scene graph flatten operations can safely combine
 * or duplicate PartBundles as necessary without affecting high-level bundle
 * operations.
 *
 * The high-level Actor class defined in direct/src/actor, for instance, will
 * store a list of PartBundleHandles instead of on actual PartBundles, so that
 * it will be immune to changes from these flatten operations.
 */

478 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203
/**
 * A base class for all things that want to be reference-counted.
 * ReferenceCount works in conjunction with PointerTo to automatically delete
 * objects when the last pointer to them goes away.
 */

479 14 MovingPartBase 0 141313 14 MovingPartBase 14 MovingPartBase 0 0 0 0 419 0 4 415 416 417 418 0 0 1 0 440 0 0 0 0 332
/**
 * This is the base class for a single animatable piece that may be bound to
 * one channel (or more, if blending is in effect).  It corresponds to, for
 * instance, a single joint or slider of a character.
 *
 * MovingPartBase does not have a particular value type.  See the derived
 * template class, MovingPart, for this.
 */

480 16 MovingPartMatrix 0 75777 16 MovingPartMatrix 16 MovingPartMatrix 0 0 0 0 423 0 1 424 0 0 1 0 481 0 0 0 0 84
/**
 * This is a particular kind of MovingPart that accepts a matrix each frame.
 */

481 32 MovingPart< ACMatrixSwitchType > 0 141313 32 MovingPart< ACMatrixSwitchType > 32 MovingPart< ACMatrixSwitchType > 0 0 0 0 423 0 3 420 421 422 0 0 1 0 479 0 0 0 1 448 0

482 16 MovingPartScalar 0 75777 16 MovingPartScalar 16 MovingPartScalar 0 0 0 0 428 0 1 429 0 0 1 0 483 0 0 0 0 84
/**
 * This is a particular kind of MovingPart that accepts a scalar each frame.
 */

483 32 MovingPart< ACScalarSwitchType > 0 141313 32 MovingPart< ACScalarSwitchType > 32 MovingPart< ACScalarSwitchType > 0 0 0 0 428 0 3 425 426 427 0 0 1 0 479 0 0 0 0 0

484 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

485 17 AnimGroup const * 0 8576 17 AnimGroup const * 17 AnimGroup const * 0 0 486 0 0 0 0 0 0 0 0 0 0

486 15 AnimGroup const 0 8832 15 AnimGroup const 15 AnimGroup const 0 0 430 0 0 0 0 0 0 0 0 0 0

487 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

488 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 489 0 0 0 0 0 0 0 0 0 0

489 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

490 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

491 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 490 0 0 0 0 0 0 0 0 0 0

492 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 431 0 0 0 0 0 0 0 0 0 0

493 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 432 0 0 0 0 0 0 0 0 0 0

494 18 AnimBundle const * 0 8576 18 AnimBundle const * 18 AnimBundle const * 0 0 495 0 0 0 0 0 0 0 0 0 0

495 16 AnimBundle const 0 8832 16 AnimBundle const 16 AnimBundle const 0 0 434 0 0 0 0 0 0 0 0 0 0

496 16 AnimBundleNode * 0 8576 16 AnimBundleNode * 16 AnimBundleNode * 0 0 437 0 0 0 0 0 0 0 0 0 0

497 22 AnimBundleNode const * 0 8576 22 AnimBundleNode const * 22 AnimBundleNode const * 0 0 498 0 0 0 0 0 0 0 0 0 0

498 20 AnimBundleNode const 0 8832 20 AnimBundleNode const 20 AnimBundleNode const 0 0 437 0 0 0 0 0 0 0 0 0 0

499 17 PartGroup const * 0 8576 17 PartGroup const * 17 PartGroup const * 0 0 500 0 0 0 0 0 0 0 0 0 0

500 15 PartGroup const 0 8832 15 PartGroup const 15 PartGroup const 0 0 440 0 0 0 0 0 0 0 0 0 0

501 22 TransformState const * 0 8576 22 TransformState const * 22 TransformState const * 0 0 502 0 0 0 0 0 0 0 0 0 0

502 20 TransformState const 0 8832 20 TransformState const 20 TransformState const 0 0 503 0 0 0 0 0 0 0 0 0 0

503 14 TransformState 0 16779264 14 TransformState 14 TransformState 0 0 0 0 0 0 0 0 0 0 0 0 734
/**
 * Indicates a coordinate-system transform on vertices.  TransformStates are
 * the primary means for storing transformations on the scene graph.
 *
 * Transforms may be specified in one of two ways: componentwise, with a pos-
 * hpr-scale, or with an arbitrary transform matrix.  If you specify a
 * transform componentwise, it will remember its original components.
 *
 * TransformState objects are managed very much like RenderState objects.
 * They are immutable and reference-counted automatically.
 *
 * You should not attempt to create or modify a TransformState object
 * directly.  Instead, call one of the make() functions to create one for you.
 * And instead of modifying a TransformState object, create a new one.
 */

504 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 505 0 0 0 0 0 0 0 0 0 0

505 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 506 0 0 0 0 0 0 0 0 0 0

506 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 507 0 0 0 0 0 0 0 0 0 0

507 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

508 17 AnimChannelBase * 0 8576 17 AnimChannelBase * 17 AnimChannelBase * 0 0 446 0 0 0 0 0 0 0 0 0 0

509 19 AnimControl const * 0 8576 19 AnimControl const * 19 AnimControl const * 0 0 510 0 0 0 0 0 0 0 0 0 0

510 17 AnimControl const 0 8832 17 AnimControl const 17 AnimControl const 0 0 443 0 0 0 0 0 0 0 0 0 0

511 13 AnimControl * 0 8576 13 AnimControl * 13 AnimControl * 0 0 443 0 0 0 0 0 0 0 0 0 0

512 16 BitArray const * 0 8576 16 BitArray const * 16 BitArray const * 0 0 513 0 0 0 0 0 0 0 0 0 0

513 14 BitArray const 0 8832 14 BitArray const 14 BitArray const 0 0 514 0 0 0 0 0 0 0 0 0 0

514 8 BitArray 0 2048 8 BitArray 8 BitArray 0 0 0 0 0 0 0 0 0 0 0 0 210
/**
 * A dynamic array with an unlimited number of bits.
 *
 * This is similar to a BitMask, except it appears to contain an infinite
 * number of bits.  You can use it very much as you would use a BitMask.
 */

515 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 444 0 0 0 0 0 0 0 0 0 0

516 15 AnimInterface * 0 8576 15 AnimInterface * 15 AnimInterface * 0 0 445 0 0 0 0 0 0 0 0 0 0

517 23 AnimChannelBase const * 0 8576 23 AnimChannelBase const * 23 AnimChannelBase const * 0 0 518 0 0 0 0 0 0 0 0 0 0

518 21 AnimChannelBase const 0 8832 21 AnimChannelBase const 21 AnimChannelBase const 0 0 446 0 0 0 0 0 0 0 0 0 0

519 35 AnimChannel< ACMatrixSwitchType > * 0 8576 35 AnimChannel< ACMatrixSwitchType > * 35 AnimChannel< ACMatrixSwitchType > * 0 0 447 0 0 0 0 0 0 0 0 0 0

520 10 LMatrix4 * 0 8576 10 LMatrix4 * 10 LMatrix4 * 0 0 448 0 0 0 0 0 0 0 0 0 0

521 11 LVecBase3 * 0 8576 11 LVecBase3 * 11 LVecBase3 * 0 0 506 0 0 0 0 0 0 0 0 0 0

522 13 LQuaternion * 0 8576 13 LQuaternion * 13 LQuaternion * 0 0 523 0 0 0 0 0 0 0 0 0 0

523 11 LQuaternion 0 2105344 11 LQuaternion 11 LQuaternion 0 0 524 0 0 0 0 0 0 0 0 0 0

524 12 LQuaternionf 0 2048 12 LQuaternionf 12 LQuaternionf 0 0 0 0 0 0 0 0 0 0 0 0 44
/**
 * This is the base quaternion class
 */

525 41 AnimChannel< ACMatrixSwitchType > const * 0 8576 41 AnimChannel< ACMatrixSwitchType > const * 41 AnimChannel< ACMatrixSwitchType > const * 0 0 526 0 0 0 0 0 0 0 0 0 0

526 39 AnimChannel< ACMatrixSwitchType > const 0 8832 39 AnimChannel< ACMatrixSwitchType > const 39 AnimChannel< ACMatrixSwitchType > const 0 0 447 0 0 0 0 0 0 0 0 0 0

527 35 AnimChannel< ACScalarSwitchType > * 0 8576 35 AnimChannel< ACScalarSwitchType > * 35 AnimChannel< ACScalarSwitchType > * 0 0 451 0 0 0 0 0 0 0 0 0 0

528 41 AnimChannel< ACScalarSwitchType > const * 0 8576 41 AnimChannel< ACScalarSwitchType > const * 41 AnimChannel< ACScalarSwitchType > const * 0 0 529 0 0 0 0 0 0 0 0 0 0

529 39 AnimChannel< ACScalarSwitchType > const 0 8832 39 AnimChannel< ACScalarSwitchType > const 39 AnimChannel< ACScalarSwitchType > const 0 0 451 0 0 0 0 0 0 0 0 0 0

530 26 AnimChannelMatrixDynamic * 0 8576 26 AnimChannelMatrixDynamic * 26 AnimChannelMatrixDynamic * 0 0 453 0 0 0 0 0 0 0 0 0 0

531 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 472 0 0 0 0 0 0 0 0 0 0

532 32 AnimChannelMatrixDynamic const * 0 8576 32 AnimChannelMatrixDynamic const * 32 AnimChannelMatrixDynamic const * 0 0 533 0 0 0 0 0 0 0 0 0 0

533 30 AnimChannelMatrixDynamic const 0 8832 30 AnimChannelMatrixDynamic const 30 AnimChannelMatrixDynamic const 0 0 453 0 0 0 0 0 0 0 0 0 0

534 27 AnimChannelMatrixXfmTable * 0 8576 27 AnimChannelMatrixXfmTable * 27 AnimChannelMatrixXfmTable * 0 0 455 0 0 0 0 0 0 0 0 0 0

535 4 char 0 8194 4 char 4 char 0 5 0 0 0 0 0 0 0 0 0 0 0

536 21 CPTA_stdfloat const * 0 8576 21 CPTA_stdfloat const * 21 CPTA_stdfloat const * 0 0 537 0 0 0 0 0 0 0 0 0 0

537 19 CPTA_stdfloat const 0 8832 19 CPTA_stdfloat const 19 CPTA_stdfloat const 0 0 456 0 0 0 0 0 0 0 0 0 0

538 33 AnimChannelMatrixXfmTable const * 0 8576 33 AnimChannelMatrixXfmTable const * 33 AnimChannelMatrixXfmTable const * 0 0 539 0 0 0 0 0 0 0 0 0 0

539 31 AnimChannelMatrixXfmTable const 0 8832 31 AnimChannelMatrixXfmTable const 31 AnimChannelMatrixXfmTable const 0 0 455 0 0 0 0 0 0 0 0 0 0

540 15 CPTA_stdfloat * 0 8576 15 CPTA_stdfloat * 15 CPTA_stdfloat * 0 0 456 0 0 0 0 0 0 0 0 0 0

541 26 AnimChannelScalarDynamic * 0 8576 26 AnimChannelScalarDynamic * 26 AnimChannelScalarDynamic * 0 0 459 0 0 0 0 0 0 0 0 0 0

542 24 AnimChannelScalarTable * 0 8576 24 AnimChannelScalarTable * 24 AnimChannelScalarTable * 0 0 462 0 0 0 0 0 0 0 0 0 0

543 30 AnimChannelScalarTable const * 0 8576 30 AnimChannelScalarTable const * 30 AnimChannelScalarTable const * 0 0 544 0 0 0 0 0 0 0 0 0 0

544 28 AnimChannelScalarTable const 0 8832 28 AnimChannelScalarTable const 28 AnimChannelScalarTable const 0 0 462 0 0 0 0 0 0 0 0 0 0

545 23 AnimControlCollection * 0 8576 23 AnimControlCollection * 23 AnimControlCollection * 0 0 463 0 0 0 0 0 0 0 0 0 0

546 29 AnimControlCollection const * 0 8576 29 AnimControlCollection const * 29 AnimControlCollection const * 0 0 547 0 0 0 0 0 0 0 0 0 0

547 27 AnimControlCollection const 0 8832 27 AnimControlCollection const 27 AnimControlCollection const 0 0 463 0 0 0 0 0 0 0 0 0 0

548 18 AnimPreloadTable * 0 8576 18 AnimPreloadTable * 18 AnimPreloadTable * 0 0 464 0 0 0 0 0 0 0 0 0 0

549 24 AnimPreloadTable const * 0 8576 24 AnimPreloadTable const * 24 AnimPreloadTable const * 0 0 550 0 0 0 0 0 0 0 0 0 0

550 22 AnimPreloadTable const 0 8832 22 AnimPreloadTable const 22 AnimPreloadTable const 0 0 464 0 0 0 0 0 0 0 0 0 0

551 12 PartSubset * 0 8576 12 PartSubset * 12 PartSubset * 0 0 466 0 0 0 0 0 0 0 0 0 0

552 18 PartSubset const * 0 8576 18 PartSubset const * 18 PartSubset const * 0 0 553 0 0 0 0 0 0 0 0 0 0

553 16 PartSubset const 0 8832 16 PartSubset const 16 PartSubset const 0 0 466 0 0 0 0 0 0 0 0 0 0

554 19 GlobPattern const * 0 8576 19 GlobPattern const * 19 GlobPattern const * 0 0 555 0 0 0 0 0 0 0 0 0 0

555 17 GlobPattern const 0 8832 17 GlobPattern const 17 GlobPattern const 0 0 556 0 0 0 0 0 0 0 0 0 0

556 11 GlobPattern 0 2048 11 GlobPattern 11 GlobPattern 0 0 0 0 0 0 0 0 0 0 0 0 538
/**
 * This class can be used to test for string matches against standard Unix-
 * shell filename globbing conventions.  It serves as a portable standin for
 * the Posix fnmatch() call.
 *
 * A GlobPattern is given a pattern string, which can contain operators like
 * *, ?, and [].  Then it can be tested against any number of candidate
 * strings; for each candidate, it will indicate whether the string matches
 * the pattern or not.  It can be used, for example, to scan a directory for
 * all files matching a particular pattern.
 */

557 23 BindAnimRequest const * 0 8576 23 BindAnimRequest const * 23 BindAnimRequest const * 0 0 558 0 0 0 0 0 0 0 0 0 0

558 21 BindAnimRequest const 0 8832 21 BindAnimRequest const 21 BindAnimRequest const 0 0 467 0 0 0 0 0 0 0 0 0 0

559 17 BindAnimRequest * 0 8576 17 BindAnimRequest * 17 BindAnimRequest * 0 0 467 0 0 0 0 0 0 0 0 0 0

560 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 561 0 0 0 0 0 0 0 0 0 0

561 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 562 0 0 0 0 0 0 0 0 0 0

562 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

563 21 LoaderOptions const * 0 8576 21 LoaderOptions const * 21 LoaderOptions const * 0 0 564 0 0 0 0 0 0 0 0 0 0

564 19 LoaderOptions const 0 8832 19 LoaderOptions const 19 LoaderOptions const 0 0 565 0 0 0 0 0 0 0 0 0 0

565 13 LoaderOptions 0 2048 13 LoaderOptions 13 LoaderOptions 0 0 0 0 0 0 0 0 0 0 0 0 65
/**
 * Specifies parameters that may be passed to the loader.
 */

566 8 Loader * 0 8576 8 Loader * 8 Loader * 0 0 567 0 0 0 0 0 0 0 0 0 0

567 6 Loader 0 2048 6 Loader 6 Loader 0 0 0 0 0 0 0 0 0 0 0 0 503
/**
 * A convenient class for loading models from disk, in bam or egg format (or
 * any of a number of other formats implemented by a LoaderFileType, such as
 * ptloader).
 *
 * This class supports synchronous as well as asynchronous loading.  In
 * asynchronous loading, the model is loaded in the background by a thread,
 * and an event will be generated when the model is available.  If threading
 * is not available, the asynchronous loading interface may be used, but it
 * loads synchronously.
 */

568 18 PartBundle const * 0 8576 18 PartBundle const * 18 PartBundle const * 0 0 569 0 0 0 0 0 0 0 0 0 0

569 16 PartBundle const 0 8832 16 PartBundle const 16 PartBundle const 0 0 469 0 0 0 0 0 0 0 0 0 0

570 22 PartBundleNode const * 0 8576 22 PartBundleNode const * 22 PartBundleNode const * 0 0 571 0 0 0 0 0 0 0 0 0 0

571 20 PartBundleNode const 0 8832 20 PartBundleNode const 20 PartBundleNode const 0 0 474 0 0 0 0 0 0 0 0 0 0

572 24 PartBundleHandle const * 0 8576 24 PartBundleHandle const * 24 PartBundleHandle const * 0 0 573 0 0 0 0 0 0 0 0 0 0

573 22 PartBundleHandle const 0 8832 22 PartBundleHandle const 22 PartBundleHandle const 0 0 477 0 0 0 0 0 0 0 0 0 0

574 22 MovingPartBase const * 0 8576 22 MovingPartBase const * 22 MovingPartBase const * 0 0 575 0 0 0 0 0 0 0 0 0 0

575 20 MovingPartBase const 0 8832 20 MovingPartBase const 20 MovingPartBase const 0 0 479 0 0 0 0 0 0 0 0 0 0

576 40 MovingPart< ACMatrixSwitchType > const * 0 8576 40 MovingPart< ACMatrixSwitchType > const * 40 MovingPart< ACMatrixSwitchType > const * 0 0 577 0 0 0 0 0 0 0 0 0 0

577 38 MovingPart< ACMatrixSwitchType > const 0 8832 38 MovingPart< ACMatrixSwitchType > const 38 MovingPart< ACMatrixSwitchType > const 0 0 481 0 0 0 0 0 0 0 0 0 0

578 40 MovingPart< ACScalarSwitchType > const * 0 8576 40 MovingPart< ACScalarSwitchType > const * 40 MovingPart< ACScalarSwitchType > const * 0 0 579 0 0 0 0 0 0 0 0 0 0

579 38 MovingPart< ACScalarSwitchType > const 0 8832 38 MovingPart< ACScalarSwitchType > const 38 MovingPart< ACScalarSwitchType > const 0 0 483 0 0 0 0 0 0 0 0 0 0

0
18
580 8 children 0 66 433 217 0 0 0 0 216 0 0 19 AnimGroup::children 0

581 15 base_frame_rate 0 2 435 226 0 0 0 0 0 0 0 27 AnimBundle::base_frame_rate 0

582 10 num_frames 0 2 436 227 0 0 0 0 0 0 0 22 AnimBundle::num_frames 0

583 6 bundle 0 2 439 231 0 0 0 0 0 0 0 22 AnimBundleNode::bundle 0

584 8 children 0 66 442 245 0 0 0 0 244 0 0 19 PartGroup::children 0

585 10 value_node 0 6 454 302 300 0 0 0 0 0 0 36 AnimChannelMatrixDynamic::value_node 0

586 6 tables 0 174 456 308 307 310 0 311 0 0 0 33 AnimChannelMatrixXfmTable::tables 0

587 5 value 0 6 460 315 313 0 0 0 0 0 0 31 AnimChannelScalarDynamic::value 0

588 10 value_node 0 6 454 316 314 0 0 0 0 0 0 36 AnimChannelScalarDynamic::value_node 0

589 5 table 0 30 456 320 319 321 322 0 0 0 0 29 AnimChannelScalarTable::table 0

590 10 blend_type 0 6 470 382 381 0 0 0 0 0 0 22 PartBundle::blend_type 0

591 15 anim_blend_flag 0 6 471 384 383 0 0 0 0 0 0 27 PartBundle::anim_blend_flag 0

592 16 frame_blend_flag 0 6 471 386 385 0 0 0 0 0 0 28 PartBundle::frame_blend_flag 0

593 10 root_xform 0 6 472 389 387 0 0 0 0 0 0 22 PartBundle::root_xform 0

594 5 nodes 0 66 473 392 0 0 0 0 391 0 0 17 PartBundle::nodes 0

595 7 bundles 0 66 475 395 0 0 0 0 394 0 0 23 PartBundleNode::bundles 0

596 14 bundle_handles 0 66 476 396 0 0 0 0 394 0 0 30 PartBundleNode::bundle_handles 0

597 6 bundle 0 6 475 398 399 0 0 0 0 0 0 24 PartBundleHandle::bundle 0

7
598 12 get_children 0 216 217 23 AnimGroup::get_children 0

599 12 get_children 0 244 245 23 PartGroup::get_children 0

600 9 get_anims 0 330 331 32 AnimControlCollection::get_anims 0

601 14 get_anim_names 0 330 332 37 AnimControlCollection::get_anim_names 0

602 9 get_nodes 0 391 392 21 PartBundle::get_nodes 0

603 11 get_bundles 0 394 395 27 PartBundleNode::get_bundles 0

604 18 get_bundle_handles 0 394 396 34 PartBundleNode::get_bundle_handles 0

