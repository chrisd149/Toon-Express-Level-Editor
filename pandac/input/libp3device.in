1592975589
3 3
11 libp3device 4 k0F5 12 panda3d.core 
138
105 8 get_time 0 4 243 21 TrackerData::get_time 0 0 180
/**
 * Returns the time at which the position information (pos and orient) are
 * effective.  It is an error to call this if has_time() does not return true.
 * See set_time().
 */
48
inline double TrackerData::get_time(void) const;

106 8 set_time 0 4 243 21 TrackerData::set_time 0 0 251
/**
 * Indicates the time at which the position information (pos and orient) are
 * effective.  This is a time elapsed in seconds since some undefined epoch;
 * it may or may not correspond to the clock time indicated in the global
 * ClockObject.
 */
47
inline void TrackerData::set_time(double time);

107 7 get_pos 0 4 243 20 TrackerData::get_pos 0 0 168
/**
 * Returns the current position of the tracker.  It is legal to call this if
 * has_pos() returns false; in this case, the position will always be (0, 0,
 * 0).
 */
55
inline LPoint3 const &TrackerData::get_pos(void) const;

108 7 set_pos 0 4 243 20 TrackerData::set_pos 0 0 143
/**
 * Indicates the current position of the tracker sensor in space.  The
 * coordinate system of this position is defined by the tracker.
 */
53
inline void TrackerData::set_pos(LPoint3 const &pos);

109 10 get_orient 0 4 243 23 TrackerData::get_orient 0 0 182
/**
 * Returns the current orientation of the tracker.  It is legal to call this
 * if has_orient() returns false; in this case, the result is always the
 * identity orientation.
 */
63
inline LOrientation const &TrackerData::get_orient(void) const;

110 10 set_orient 0 4 243 23 TrackerData::set_orient 0 0 225
/**
 * Indicates the current orientation of the tracker sensor in space.  The
 * coordinate system of this orientation is defined by the tracker, but should
 * be the same coordinate system as that reflected by set_pos().
 */
64
inline void TrackerData::set_orient(LOrientation const &orient);

111 6 get_dt 0 4 243 19 TrackerData::get_dt 0 0 188
/**
 * Returns the amount of elapsed time over which the information (pos and
 * orient) were computed.  It is an error to call this if has_dt() does not
 * return true.  See set_dt().
 */
46
inline double TrackerData::get_dt(void) const;

112 6 set_dt 0 4 243 19 TrackerData::set_dt 0 0 259
/**
 * Indicates the amount of elapsed time over which which the information (pos
 * and orient) were computed.  This only makes sense if the information
 * represents velocity or acceleration, rather than position.  This is an
 * elapsed time in seconds.
 */
43
inline void TrackerData::set_dt(double dt);

113 12 ~TrackerData 0 4 243 25 TrackerData::~TrackerData 0 0 0
32
TrackerData::~TrackerData(void);

114 22 operator typecast bool 0 132 257 48 InputDevice::ButtonState::operator typecast bool 0 1 21 0
21
operator bool (void);

115 8 is_known 0 4 257 34 InputDevice::ButtonState::is_known 0 0 55
/**
 * True if the button state is currently known.
 */
59
inline bool InputDevice::ButtonState::is_known(void) const;

116 10 is_pressed 0 4 257 36 InputDevice::ButtonState::is_pressed 0 0 63
/**
 * True if the button is currently known to be pressed.
 */
61
inline bool InputDevice::ButtonState::is_pressed(void) const;

117 10 get_handle 0 20 257 36 InputDevice::ButtonState::get_handle 0 0 57
getter for ButtonHandle InputDevice::ButtonState::handle;
62
ButtonHandle InputDevice::ButtonState::get_handle(void) const;

118 11 ButtonState 0 4 257 37 InputDevice::ButtonState::ButtonState 0 1 20 10
/**
 *
 */
89
inline InputDevice::ButtonState::ButtonState(InputDevice::ButtonState const &) = default;

119 12 ~ButtonState 0 4 257 38 InputDevice::ButtonState::~ButtonState 0 0 0
45
InputDevice::ButtonState::~ButtonState(void);

120 22 operator typecast bool 0 132 260 46 InputDevice::AxisState::operator typecast bool 0 1 23 0
21
operator bool (void);

121 8 get_axis 0 20 260 32 InputDevice::AxisState::get_axis 0 0 58
getter for InputDevice::Axis InputDevice::AxisState::axis;
63
InputDevice::Axis InputDevice::AxisState::get_axis(void) const;

122 8 set_axis 0 36 260 32 InputDevice::AxisState::set_axis 0 0 58
setter for InputDevice::Axis InputDevice::AxisState::axis;
63
void InputDevice::AxisState::set_axis(InputDevice::Axis value);

123 9 get_value 0 20 260 33 InputDevice::AxisState::get_value 0 0 48
getter for double InputDevice::AxisState::value;
53
double InputDevice::AxisState::get_value(void) const;

124 9 set_value 0 36 260 33 InputDevice::AxisState::set_value 0 0 48
setter for double InputDevice::AxisState::value;
53
void InputDevice::AxisState::set_value(double value);

125 9 get_known 0 20 260 33 InputDevice::AxisState::get_known 0 0 46
getter for bool InputDevice::AxisState::known;
51
bool InputDevice::AxisState::get_known(void) const;

126 9 set_known 0 36 260 33 InputDevice::AxisState::set_known 0 0 46
setter for bool InputDevice::AxisState::known;
51
void InputDevice::AxisState::set_known(bool value);

127 9 AxisState 0 4 260 33 InputDevice::AxisState::AxisState 0 1 22 0
83
inline InputDevice::AxisState::AxisState(InputDevice::AxisState const &) = default;

128 10 ~AxisState 0 4 260 34 InputDevice::AxisState::~AxisState 0 0 0
41
InputDevice::AxisState::~AxisState(void);

129 9 get_level 0 20 261 35 InputDevice::BatteryData::get_level 0 0 53
getter for short int InputDevice::BatteryData::level;
58
short int InputDevice::BatteryData::get_level(void) const;

130 9 set_level 0 36 261 35 InputDevice::BatteryData::set_level 0 0 53
setter for short int InputDevice::BatteryData::level;
58
void InputDevice::BatteryData::set_level(short int value);

131 13 get_max_level 0 20 261 39 InputDevice::BatteryData::get_max_level 0 0 57
getter for short int InputDevice::BatteryData::max_level;
62
short int InputDevice::BatteryData::get_max_level(void) const;

132 13 set_max_level 0 36 261 39 InputDevice::BatteryData::set_max_level 0 0 57
setter for short int InputDevice::BatteryData::max_level;
62
void InputDevice::BatteryData::set_max_level(short int value);

133 11 BatteryData 0 4 261 37 InputDevice::BatteryData::BatteryData 0 2 24 25 0
151
inline InputDevice::BatteryData::BatteryData(void) = default;
inline InputDevice::BatteryData::BatteryData(InputDevice::BatteryData const &) = default;

134 12 ~BatteryData 0 4 261 38 InputDevice::BatteryData::~BatteryData 0 0 0
45
InputDevice::BatteryData::~BatteryData(void);

135 8 get_name 0 4 251 21 InputDevice::get_name 0 0 81
/**
 * Returns a human-readable name for the device.  Not necessarily unique.
 */
53
inline std::string InputDevice::get_name(void) const;

136 16 get_manufacturer 0 4 251 29 InputDevice::get_manufacturer 0 0 103
/**
 * Returns a string containing the manufacturer of the device, if this
 * information is known.
 */
61
inline std::string InputDevice::get_manufacturer(void) const;

137 17 get_serial_number 0 4 251 30 InputDevice::get_serial_number 0 0 104
/**
 * Returns a string containing the serial number of the device, if this
 * information is known.
 */
62
inline std::string InputDevice::get_serial_number(void) const;

138 13 get_vendor_id 0 4 251 26 InputDevice::get_vendor_id 0 0 104
/**
 * Returns a string containing the USB vendor ID of the device, if this
 * information is known.
 */
65
inline unsigned short int InputDevice::get_vendor_id(void) const;

139 14 get_product_id 0 4 251 27 InputDevice::get_product_id 0 0 105
/**
 * Returns a string containing the USB product ID of the device, if this
 * information is known.
 */
66
inline unsigned short int InputDevice::get_product_id(void) const;

140 12 is_connected 0 4 251 25 InputDevice::is_connected 0 0 131
/**
 * Returns true if the device is still connected and able to receive data,
 * false otherwise.  May return false positives.
 */
50
inline bool InputDevice::is_connected(void) const;

141 16 get_device_class 0 4 251 29 InputDevice::get_device_class 0 0 133
/**
 * Returns an identification of the general type of device.  If this could not
 * be determined, returns DeviceClass.unknown.
 */
74
inline InputDevice::DeviceClass InputDevice::get_device_class(void) const;

142 11 has_feature 0 4 251 24 InputDevice::has_feature 0 1 1 102
// Determine supported features

/**
 * Returns true if the device supports the indicated feature.
 */
73
inline bool InputDevice::has_feature(InputDevice::Feature feature) const;

143 11 get_tracker 0 4 251 24 InputDevice::get_tracker 0 0 140
/**
 * Returns the TrackerData associated with the input device's tracker.  This
 * only makes sense if has_tracker() also returns true.
 */
56
inline TrackerData InputDevice::get_tracker(void) const;

144 11 has_tracker 0 4 251 24 InputDevice::has_tracker 0 1 16 115
/**
 * Returns true if the device features a tracker that can track position and/or
 * orientation in 3D space.
 */
49
inline bool InputDevice::has_tracker(void) const;

145 11 get_battery 0 4 251 24 InputDevice::get_battery 0 0 138
/**
 * Returns a rough indication of the battery level, ranging from 0 (completely
 * empty battery) to the indicated max_level value.
 */
69
inline InputDevice::BatteryData InputDevice::get_battery(void) const;

146 11 has_battery 0 4 251 24 InputDevice::has_battery 0 1 17 99
/**
 * Returns true if the device may be able to provide information about its
 * battery life.
 */
49
inline bool InputDevice::has_battery(void) const;

147 15 get_num_buttons 0 4 251 28 InputDevice::get_num_buttons 0 1 18 279
/**
 * Returns the number of buttons known to the device.  This includes those
 * buttons whose state has been seen, as well as buttons that have been
 * associated with a ButtonHandle even if their state is unknown.  This number
 * may change as more buttons are discovered.
 */
60
inline std::size_t InputDevice::get_num_buttons(void) const;

148 10 get_button 0 4 251 23 InputDevice::get_button 0 0 128
/**
 * Returns the ButtonState that is set at the given index, or throw an assert
 * if the index was not found in the list.
 */
81
inline InputDevice::ButtonState InputDevice::get_button(std::size_t index) const;

149 12 get_num_axes 0 4 251 25 InputDevice::get_num_axes 0 1 19 126
/**
 * Returns the number of analog axes known to the InputDevice.  This number
 * may change as more axes are discovered.
 */
57
inline std::size_t InputDevice::get_num_axes(void) const;

150 8 get_axis 0 4 251 21 InputDevice::get_axis 0 0 127
/**
 * Returns the axis state that is set at the given index, or throw an assert
 * if the index was not found in the list.
 */
77
inline InputDevice::AxisState InputDevice::get_axis(std::size_t index) const;

151 10 map_button 0 4 251 23 InputDevice::map_button 0 1 2 540
// Associate buttons/axes with symbolic handles.

/**
 * Associates the indicated ButtonHandle with the button of the indicated index
 * number.  When the given button index changes state, a corresponding
 * ButtonEvent will be generated with the given ButtonHandle.  Pass
 * ButtonHandle::none() to turn off any association.
 *
 * It is not necessary to call this if you simply want to query the state of
 * the various buttons by index number; this is only necessary in order to
 * generate ButtonEvents when the buttons change state.
 */
76
inline void InputDevice::map_button(std::size_t index, ButtonHandle handle);

152 8 map_axis 0 4 251 21 InputDevice::map_axis 0 1 3 251
/**
 * Associates the indicated Axis with the axis of the indicated index
 * number.  Pass Axis::none to turn off any association.
 *
 * It is not necessary to call this if you simply want to query the state of
 * the various axes by index number.
 */
77
inline void InputDevice::map_axis(std::size_t index, InputDevice::Axis axis);

153 11 find_button 0 4 251 24 InputDevice::find_button 0 1 4 137
/**
 * Returns the first ButtonState found with the given axis, or throw an assert
 * if the button handle was not found in the list.
 */
84
inline InputDevice::ButtonState InputDevice::find_button(ButtonHandle handle) const;

154 9 find_axis 0 4 251 22 InputDevice::find_axis 0 1 5 127
/**
 * Returns the first AnalogAxis found with the given axis, or throw an assert
 * if the axis was not found in the list.
 */
83
inline InputDevice::AxisState InputDevice::find_axis(InputDevice::Axis axis) const;

155 13 set_vibration 0 4 251 26 InputDevice::set_vibration 0 1 6 267
// Enable rumble force-feedback effects

/**
 * Sets the strength of the vibration effect, if supported.  The values are
 * clamped to 0-1 range. The first value axes the low-frequency rumble
 * motor, whereas the second axes the high-frequency motor, if present.
 */
67
inline void InputDevice::set_vibration(double strong, double weak);

156 21 enable_pointer_events 0 4 251 34 InputDevice::enable_pointer_events 0 1 7 59
/**
 * Enables the generation of mouse-movement events.
 */
53
inline void InputDevice::enable_pointer_events(void);

157 22 disable_pointer_events 0 4 251 35 InputDevice::disable_pointer_events 0 1 8 60
/**
 * Disables the generation of mouse-movement events.
 */
54
inline void InputDevice::disable_pointer_events(void);

158 4 poll 0 4 251 17 InputDevice::poll 0 1 9 233
/**
 * Polls the input device for new activity, to ensure it contains the latest
 * events.  This will only have any effect for some types of input devices;
 * others may be updated automatically, and this method will be a no-op.
 */
29
void InputDevice::poll(void);

159 16 has_button_event 0 4 251 29 InputDevice::has_button_event 0 1 10 218
/**
 * Returns true if this device has a pending button event (a mouse button or
 * keyboard button down/up), false otherwise.  If this returns true, the
 * particular event may be extracted via get_button_event().
 */
47
bool InputDevice::has_button_event(void) const;

160 17 get_button_events 0 4 251 30 InputDevice::get_button_events 0 1 11 92
/**
 * Returns the list of recently-generated ButtonEvents.
 * The list is also cleared.
 */
66
PointerTo< ButtonEventList > InputDevice::get_button_events(void);

161 17 has_pointer_event 0 4 251 30 InputDevice::has_pointer_event 0 1 12 198
/**
 * Returns true if this device has a pending pointer event (a mouse movement),
 * or false otherwise.  If this returns true, the particular event may be
 * extracted via get_pointer_event().
 */
48
bool InputDevice::has_pointer_event(void) const;

162 18 get_pointer_events 0 4 251 31 InputDevice::get_pointer_events 0 1 13 99
/**
 * Returns a PointerEventList containing all the recent pointer events.
 * Clears the list.
 */
68
PointerTo< PointerEventList > InputDevice::get_pointer_events(void);

163 6 output 0 6 251 19 InputDevice::output 0 1 14 58
/**
 * Writes a one-line string describing the device.
 */
58
virtual void InputDevice::output(std::ostream &out) const;

164 11 get_buttons 0 20 251 24 InputDevice::get_buttons 0 0 54
getter for InputDevice::Buttons InputDevice::_buttons;
58
InputDevice::Buttons InputDevice::get_buttons(void) const;

165 8 get_axes 0 20 251 21 InputDevice::get_axes 0 0 48
getter for InputDevice::Axes InputDevice::_axes;
52
InputDevice::Axes InputDevice::get_axes(void) const;

166 16 get_pointer_data 0 20 251 29 InputDevice::get_pointer_data 0 0 50
getter for PointerData InputDevice::_pointer_data;
61
PointerData const &InputDevice::get_pointer_data(void) const;

167 16 get_battery_data 0 20 251 29 InputDevice::get_battery_data 0 0 63
getter for InputDevice::BatteryData InputDevice::_battery_data;
67
InputDevice::BatteryData InputDevice::get_battery_data(void) const;

168 16 get_tracker_data 0 20 251 29 InputDevice::get_tracker_data 0 0 50
getter for TrackerData InputDevice::_tracker_data;
61
TrackerData const &InputDevice::get_tracker_data(void) const;

169 14 get_class_type 0 4 251 27 InputDevice::get_class_type 0 1 15 0
52
static TypeHandle InputDevice::get_class_type(void);

170 24 fork_asynchronous_thread 0 4 271 36 ClientBase::fork_asynchronous_thread 0 1 26 314
/**
 * Forks a separate thread to do all the polling of connected devices.  The
 * forked thread will poll after every poll_time seconds has elapsed.  Returns
 * true if the fork was successful, or false otherwise (for instance, because
 * we were already forked, or because asynchronous threads are disabled).
 */
60
bool ClientBase::fork_asynchronous_thread(double poll_time);

171 9 is_forked 0 4 271 21 ClientBase::is_forked 0 1 27 130
/**
 * Returns true if the ClientBase has been forked (and, therefore, poll() does
 * not need to be called), false otherwise.
 */
46
inline bool ClientBase::is_forked(void) const;

172 4 poll 0 4 271 16 ClientBase::poll 0 1 28 183
/**
 * Initiates a poll of the client devices, if we are not forked and if we have
 * not already polled this frame.  Returns true if the poll occurred, or false
 * if it did not.
 */
35
inline bool ClientBase::poll(void);

173 18 get_last_poll_time 0 4 271 30 ClientBase::get_last_poll_time 0 1 29 118
/**
 * Returns the time (according to the global ClockObject's get_real_time()
 * method) of the last device poll.
 */
57
inline double ClientBase::get_last_poll_time(void) const;

174 21 set_coordinate_system 0 4 271 33 ClientBase::set_coordinate_system 0 1 30 138
/**
 * Specifies the coordinate system that all devices associated with this
 * client will operate in.  Normally, this is CS_default.
 */
67
inline void ClientBase::set_coordinate_system(CoordinateSystem cs);

175 21 get_coordinate_system 0 4 271 33 ClientBase::get_coordinate_system 0 1 31 136
/**
 * Returns the coordinate system that all devices associated with this client
 * will operate in.  Normally, this is CS_default.
 */
70
inline CoordinateSystem ClientBase::get_coordinate_system(void) const;

176 14 get_class_type 0 4 271 26 ClientBase::get_class_type 0 1 32 0
51
static TypeHandle ClientBase::get_class_type(void);

177 10 AnalogNode 0 4 272 22 AnalogNode::AnalogNode 0 3 33 34 35 22
/**
 *
 */

/**
 *
 */
199
explicit AnalogNode::AnalogNode(ClientBase *client, std::string const &device_name);
explicit AnalogNode::AnalogNode(InputDevice *device);
inline AnalogNode::AnalogNode(AnalogNode const &) = default;

178 8 is_valid 0 4 272 20 AnalogNode::is_valid 0 1 36 97
/**
 * Returns true if the AnalogNode is valid and connected to a server, false
 * otherwise.
 */
45
inline bool AnalogNode::is_valid(void) const;

179 16 get_num_controls 0 4 272 28 AnalogNode::get_num_controls 0 1 37 133
/**
 * Returns the number of analog controls known to the AnalogNode.  This number
 * may change as more controls are discovered.
 */
52
inline int AnalogNode::get_num_controls(void) const;

180 17 get_control_state 0 4 272 29 AnalogNode::get_control_state 0 1 38 193
/**
 * Returns the current position of indicated analog control identified by its
 * index number, or 0.0 if the control is unknown.  The normal range of a
 * single control is -1.0 to 1.0.
 */
61
inline double AnalogNode::get_control_state(int index) const;

181 16 is_control_known 0 4 272 28 AnalogNode::is_control_known 0 1 39 153
/**
 * Returns true if the state of the indicated analog control is known, or
 * false if we have never heard anything about this particular control.
 */
58
inline bool AnalogNode::is_control_known(int index) const;

182 10 set_output 0 4 272 22 AnalogNode::set_output 0 1 40 314
/**
 * Causes a particular analog control to be placed in the data graph for the
 * indicated channel.  Normally, a mouse uses channels 0 and 1 for the X and Y
 * information, respectively; channels 0, 1, and 2 are available.  If flip is
 * true, the analog control value will be reversed before outputting it.
 */
70
inline void AnalogNode::set_output(int channel, int index, bool flip);

183 12 clear_output 0 4 272 24 AnalogNode::clear_output 0 1 41 107
/**
 * Removes the output to the data graph associated with the indicated channel.
 * See set_output().
 */
50
inline void AnalogNode::clear_output(int channel);

184 10 get_output 0 4 272 22 AnalogNode::get_output 0 1 42 174
/**
 * Returns the analog control index that is output to the data graph on the
 * indicated channel, or -1 if no control is output on that channel.  See
 * set_output().
 */
53
inline int AnalogNode::get_output(int channel) const;

185 17 is_output_flipped 0 4 272 29 AnalogNode::is_output_flipped 0 1 43 143
/**
 * Returns true if the analog control index that is output to the data graph
 * on the indicated channel is flipped.  See set_output().
 */
61
inline bool AnalogNode::is_output_flipped(int channel) const;

186 14 get_class_type 0 4 272 26 AnalogNode::get_class_type 0 1 44 0
51
static TypeHandle AnalogNode::get_class_type(void);

187 10 ButtonNode 0 4 274 22 ButtonNode::ButtonNode 0 3 45 46 47 22
/**
 *
 */

/**
 *
 */
199
explicit ButtonNode::ButtonNode(ClientBase *client, std::string const &device_name);
explicit ButtonNode::ButtonNode(InputDevice *device);
inline ButtonNode::ButtonNode(ButtonNode const &) = default;

188 8 is_valid 0 4 274 20 ButtonNode::is_valid 0 1 48 97
/**
 * Returns true if the ButtonNode is valid and connected to a server, false
 * otherwise.
 */
45
inline bool ButtonNode::is_valid(void) const;

189 15 get_num_buttons 0 4 274 27 ButtonNode::get_num_buttons 0 1 49 283
/**
 * Returns the number of buttons known to the ButtonNode.  This includes those
 * buttons whose state has been seen, as well as buttons that have been
 * associated with a ButtonHandle even if their state is unknown.  This number
 * may change as more buttons are discovered.
 */
51
inline int ButtonNode::get_num_buttons(void) const;

190 14 set_button_map 0 4 274 26 ButtonNode::set_button_map 0 1 50 490
/**
 * Associates the indicated ButtonHandle with the button of the indicated
 * index number.  When the given button index changes state, a corresponding
 * ButtonEvent will be generated with the given ButtonHandle.  Pass
 * ButtonHandle::none() to turn off any association.
 *
 * It is not necessary to call this if you simply want to query the state of
 * the various buttons by index number; this is only necessary in order to
 * generate ButtonEvents when the buttons change state.
 */
71
inline void ButtonNode::set_button_map(int index, ButtonHandle button);

191 14 get_button_map 0 4 274 26 ButtonNode::get_button_map 0 1 51 184
/**
 * Returns the ButtonHandle that was previously associated with the given
 * index number by a call to set_button_map(), or ButtonHandle::none() if no
 * button was associated.
 */
64
inline ButtonHandle ButtonNode::get_button_map(int index) const;

192 16 get_button_state 0 4 274 28 ButtonNode::get_button_state 0 1 52 147
/**
 * Returns true if the indicated button (identified by its index number) is
 * currently known to be down, or false if it is up or unknown.
 */
58
inline bool ButtonNode::get_button_state(int index) const;

193 15 is_button_known 0 4 274 27 ButtonNode::is_button_known 0 1 53 144
/**
 * Returns true if the state of the indicated button is known, or false if we
 * have never heard anything about this particular button.
 */
57
inline bool ButtonNode::is_button_known(int index) const;

194 14 get_class_type 0 4 274 26 ButtonNode::get_class_type 0 1 54 0
51
static TypeHandle ButtonNode::get_class_type(void);

195 8 DialNode 0 4 275 18 DialNode::DialNode 0 2 55 56 10
/**
 *
 */
135
explicit DialNode::DialNode(ClientBase *client, std::string const &device_name);
inline DialNode::DialNode(DialNode const &) = default;

196 8 is_valid 0 4 275 18 DialNode::is_valid 0 1 57 95
/**
 * Returns true if the DialNode is valid and connected to a server, false
 * otherwise.
 */
43
inline bool DialNode::is_valid(void) const;

197 13 get_num_dials 0 4 275 23 DialNode::get_num_dials 0 1 58 123
/**
 * Returns the number of dial dials known to the DialNode.  This number may
 * change as more dials are discovered.
 */
47
inline int DialNode::get_num_dials(void) const;

198 9 read_dial 0 4 275 19 DialNode::read_dial 0 1 59 216
/**
 * Returns the number of complete revolutions of the dial since the last time
 * read_dial() was called.  This is a destructive operation; it is not
 * possible to read the dial without resetting the counter.
 */
45
inline double DialNode::read_dial(int index);

199 13 is_dial_known 0 4 275 23 DialNode::is_dial_known 0 1 60 145
/**
 * Returns true if the state of the indicated dial dial is known, or false if
 * we have never heard anything about this particular dial.
 */
53
inline bool DialNode::is_dial_known(int index) const;

200 14 get_class_type 0 4 275 24 DialNode::get_class_type 0 1 61 0
49
static TypeHandle DialNode::get_class_type(void);

201 14 InputDeviceSet 0 4 276 30 InputDeviceSet::InputDeviceSet 0 2 62 63 22
/**
 *
 */

/**
 *
 */
97
InputDeviceSet::InputDeviceSet(void);
InputDeviceSet::InputDeviceSet(InputDeviceSet const &copy);

202 10 operator = 0 4 276 26 InputDeviceSet::operator = 0 1 64 0
60
void InputDeviceSet::operator =(InputDeviceSet const &copy);

203 15 ~InputDeviceSet 0 4 276 31 InputDeviceSet::~InputDeviceSet 0 0 10
/**
 *
 */
45
inline InputDeviceSet::~InputDeviceSet(void);

204 5 clear 0 4 276 21 InputDeviceSet::clear 0 1 65 56
/**
 * Removes all InputDevices from the collection.
 */
33
void InputDeviceSet::clear(void);

205 7 reserve 0 4 276 23 InputDeviceSet::reserve 0 1 66 160
/**
 * This is a hint to Panda to allocate enough memory to hold the given number
 * of InputDevices, if you know ahead of time how many you will be adding.
 */
46
void InputDeviceSet::reserve(std::size_t num);

206 11 operator [] 0 4 276 27 InputDeviceSet::operator [] 0 1 67 57
/**
 * Returns the nth InputDevice in the collection.
 */
73
inline InputDevice *InputDeviceSet::operator [](std::size_t index) const;

207 4 size 0 4 276 20 InputDeviceSet::size 0 1 68 59
/**
 * Returns the number of devices in the collection.
 */
52
inline std::size_t InputDeviceSet::size(void) const;

208 6 output 0 4 276 22 InputDeviceSet::output 0 1 69 103
/**
 * Writes a brief one-line description of the InputDeviceSet to the indicated
 * output stream.
 */
53
void InputDeviceSet::output(std::ostream &out) const;

209 5 write 0 4 276 21 InputDeviceSet::write 0 1 70 108
/**
 * Writes a complete multi-line description of the InputDeviceSet to the
 * indicated output stream.
 */
74
void InputDeviceSet::write(std::ostream &out, int indent_level = 0) const;

210 11 get_devices 0 4 277 31 InputDeviceManager::get_devices 0 2 71 72 156
/**
 * Description: Returns all currently connected devices.
 */

/**
 * Description: Returns all currently connected devices of the given device class.
 */
152
InputDeviceSet InputDeviceManager::get_devices(void) const;
InputDeviceSet InputDeviceManager::get_devices(InputDevice::DeviceClass device_class) const;

211 10 add_device 0 4 277 30 InputDeviceManager::add_device 0 1 73 166
/**
 * Called when a new device has been discovered.  This may also be used to
 * register virtual devices.
 *
 * This causes a connect-device event to be thrown.
 */
57
void InputDeviceManager::add_device(InputDevice *device);

212 13 remove_device 0 4 277 33 InputDeviceManager::remove_device 0 1 74 166
/**
 * Called when a device has been removed, or when a device should otherwise no
 * longer be tracked.
 *
 * This causes a disconnect-device event to be thrown.
 */
60
void InputDeviceManager::remove_device(InputDevice *device);

213 6 update 0 6 277 26 InputDeviceManager::update 0 1 75 109
/**
 * Polls the system to see if there are any new devices.  In some
 * implementations this is a no-op.
 */
46
virtual void InputDeviceManager::update(void);

214 14 get_global_ptr 0 4 277 34 InputDeviceManager::get_global_ptr 0 1 76 61
/**
 * Returns the singleton InputDeviceManager instance.
 */
75
static inline InputDeviceManager *InputDeviceManager::get_global_ptr(void);

215 15 InputDeviceNode 0 4 278 32 InputDeviceNode::InputDeviceNode 0 2 77 78 0
155
InputDeviceNode::InputDeviceNode(InputDevice *device, std::string const &name);
inline InputDeviceNode::InputDeviceNode(InputDeviceNode const &) = default;

216 10 get_device 0 4 278 27 InputDeviceNode::get_device 0 0 41
/**
 * Returns the associated device.
 */
65
PointerTo< InputDevice > InputDeviceNode::get_device(void) const;

217 10 set_device 0 4 278 27 InputDeviceNode::set_device 0 0 71
/**
 * Redirects the class to get the data from a different device.
 */
54
void InputDeviceNode::set_device(InputDevice *device);

218 14 get_class_type 0 4 278 31 InputDeviceNode::get_class_type 0 1 79 0
56
static TypeHandle InputDeviceNode::get_class_type(void);

219 16 ~InputDeviceNode 0 4 278 33 InputDeviceNode::~InputDeviceNode 0 0 0
40
InputDeviceNode::~InputDeviceNode(void);

220 19 LinuxJoystickDevice 0 4 280 40 LinuxJoystickDevice::LinuxJoystickDevice 0 1 80 85
/**
 * Creates a new device using the Linux joystick device with the given index.
 */
94
LinuxJoystickDevice::LinuxJoystickDevice(LinuxInputDeviceManager *manager, std::size_t index);

221 12 check_events 0 4 280 33 LinuxJoystickDevice::check_events 0 1 81 52
/**
 * Returns true if there are pending events.
 */
51
bool LinuxJoystickDevice::check_events(void) const;

222 14 get_class_type 0 4 280 35 LinuxJoystickDevice::get_class_type 0 1 82 0
60
static TypeHandle LinuxJoystickDevice::get_class_type(void);

223 11 TrackerNode 0 4 281 24 TrackerNode::TrackerNode 0 3 83 84 85 22
/**
 *
 */

/**
 *
 */
206
explicit TrackerNode::TrackerNode(ClientBase *client, std::string const &device_name);
explicit TrackerNode::TrackerNode(InputDevice *device);
inline TrackerNode::TrackerNode(TrackerNode const &) = default;

224 8 is_valid 0 4 281 21 TrackerNode::is_valid 0 1 86 98
/**
 * Returns true if the TrackerNode is valid and connected to a server, false
 * otherwise.
 */
46
inline bool TrackerNode::is_valid(void) const;

225 7 get_pos 0 4 281 20 TrackerNode::get_pos 0 1 87 75
/**
 * Returns the current position of the tracker, if it is available.
 */
55
inline LPoint3 const &TrackerNode::get_pos(void) const;

226 10 get_orient 0 4 281 23 TrackerNode::get_orient 0 1 88 78
/**
 * Returns the current orientation of the tracker, if it is available.
 */
63
inline LOrientation const &TrackerNode::get_orient(void) const;

227 13 get_transform 0 4 281 26 TrackerNode::get_transform 0 1 89 96
/**
 * Returns the current position and orientation of the tracker, as a combined
 * matrix.
 */
62
inline LMatrix4 const &TrackerNode::get_transform(void) const;

228 8 get_time 0 4 281 21 TrackerNode::get_time 0 1 90 57
/**
 * Returns the time of the tracker's last update.
 */
48
inline double TrackerNode::get_time(void) const;

229 8 has_time 0 4 281 21 TrackerNode::has_time 0 1 91 51
/**
 * True if this data comes with timestamps.
 */
46
inline bool TrackerNode::has_time(void) const;

230 29 set_tracker_coordinate_system 0 4 281 42 TrackerNode::set_tracker_coordinate_system 0 1 92 257
/**
 * Specifies the coordinate system that the tracker associated with this node
 * will operate in.  Normally, this is set from the ClientBase that's used to
 * create the TrackerNode, so it should not need to be set on an individual
 * tracker basis.
 */
76
inline void TrackerNode::set_tracker_coordinate_system(CoordinateSystem cs);

231 29 get_tracker_coordinate_system 0 4 281 42 TrackerNode::get_tracker_coordinate_system 0 1 93 103
/**
 * Returns the coordinate system that the tracker associated with this node
 * will operate in.
 */
79
inline CoordinateSystem TrackerNode::get_tracker_coordinate_system(void) const;

232 27 set_graph_coordinate_system 0 4 281 40 TrackerNode::set_graph_coordinate_system 0 1 94 165
/**
 * Specifies the coordinate system that the TrackerNode will convert its
 * transform into for passing down the data graph.  Normally, this is
 * CS_default.
 */
74
inline void TrackerNode::set_graph_coordinate_system(CoordinateSystem cs);

233 27 get_graph_coordinate_system 0 4 281 40 TrackerNode::get_graph_coordinate_system 0 1 95 163
/**
 * Returns the coordinate system that the TrackerNode will convert its
 * transform into for passing down the data graph.  Normally, this is
 * CS_default.
 */
77
inline CoordinateSystem TrackerNode::get_graph_coordinate_system(void) const;

234 14 get_class_type 0 4 281 27 TrackerNode::get_class_type 0 1 96 0
52
static TypeHandle TrackerNode::get_class_type(void);

235 12 VirtualMouse 0 4 282 26 VirtualMouse::VirtualMouse 0 2 97 98 10
/**
 *
 */
128
explicit VirtualMouse::VirtualMouse(std::string const &name);
inline VirtualMouse::VirtualMouse(VirtualMouse const &) = default;

236 13 set_mouse_pos 0 4 282 27 VirtualMouse::set_mouse_pos 0 1 99 155
/**
 * Sets the current mouse pixel location, where (0,0) is the upper left, and
 * (width-1, height-1) is the lower right pixel of the virtual window.
 */
47
void VirtualMouse::set_mouse_pos(int x, int y);

237 15 set_window_size 0 4 282 29 VirtualMouse::set_window_size 0 1 100 136
/**
 * Sets the size of the "window" in which the mouse rolls.  This changes the
 * meaning of the values passed to set_mouse_pos().
 */
58
void VirtualMouse::set_window_size(int width, int height);

238 12 set_mouse_on 0 4 282 26 VirtualMouse::set_mouse_on 0 1 101 217
/**
 * Sets whether the mouse should appear to be within the window or not.  If
 * this is true, the mouse is within the window; if false, the mouse is not
 * within the window (and set_mouse_pos() means nothing).
 */
43
void VirtualMouse::set_mouse_on(bool flag);

239 12 press_button 0 4 282 26 VirtualMouse::press_button 0 1 102 167
/**
 * Simulates a mouse or keyboard button being depressed.  This should be
 * followed up by a call to release_button() sometime later (possibly
 * immediately).
 */
53
void VirtualMouse::press_button(ButtonHandle button);

240 14 release_button 0 4 282 28 VirtualMouse::release_button 0 1 103 105
/**
 * Simulates the button being released.  This should follow a previous call to
 * press_button().
 */
55
void VirtualMouse::release_button(ButtonHandle button);

241 14 get_class_type 0 4 282 28 VirtualMouse::get_class_type 0 1 104 0
53
static TypeHandle VirtualMouse::get_class_type(void);

242 13 ~VirtualMouse 0 4 282 27 VirtualMouse::~VirtualMouse 0 0 0
34
VirtualMouse::~VirtualMouse(void);

104
1 0 0 6 80 258 0 0 69 /**
 * Returns true if the device supports the indicated feature.
 */ 2 4 this 3 283  7 feature 1 254  
2 0 0 4 93 289 0 0 490 /**
 * Associates the indicated ButtonHandle with the button of the indicated index
 * number.  When the given button index changes state, a corresponding
 * ButtonEvent will be generated with the given ButtonHandle.  Pass
 * ButtonHandle::none() to turn off any association.
 *
 * It is not necessary to call this if you simply want to query the state of
 * the various buttons by index number; this is only necessary in order to
 * generate ButtonEvents when the buttons change state.
 */ 3 4 this 3 285  5 index 1 286  6 handle 1 288  
3 0 0 4 94 289 0 0 251 /**
 * Associates the indicated Axis with the axis of the indicated index
 * number.  Pass Axis::none to turn off any association.
 *
 * It is not necessary to call this if you simply want to query the state of
 * the various axes by index number.
 */ 3 4 this 3 285  5 index 1 286  4 axis 1 255  
4 0 0 7 95 290 119 0 137 /**
 * Returns the first ButtonState found with the given axis, or throw an assert
 * if the button handle was not found in the list.
 */ 2 4 this 3 283  6 handle 1 288  
5 0 0 7 96 291 128 0 127 /**
 * Returns the first AnalogAxis found with the given axis, or throw an assert
 * if the axis was not found in the list.
 */ 2 4 this 3 283  4 axis 1 255  
6 0 0 4 97 289 0 0 226 /**
 * Sets the strength of the vibration effect, if supported.  The values are
 * clamped to 0-1 range. The first value axes the low-frequency rumble
 * motor, whereas the second axes the high-frequency motor, if present.
 */ 3 4 this 3 285  6 strong 1 244  4 weak 1 244  
7 0 0 4 98 289 0 0 59 /**
 * Enables the generation of mouse-movement events.
 */ 1 4 this 3 285  
8 0 0 4 99 289 0 0 60 /**
 * Disables the generation of mouse-movement events.
 */ 1 4 this 3 285  
9 0 0 4 100 289 0 0 233 /**
 * Polls the input device for new activity, to ensure it contains the latest
 * events.  This will only have any effect for some types of input devices;
 * others may be updated automatically, and this method will be a no-op.
 */ 1 4 this 3 285  
10 0 0 6 101 258 0 0 218 /**
 * Returns true if this device has a pending button event (a mouse button or
 * keyboard button down/up), false otherwise.  If this returns true, the
 * particular event may be extracted via get_button_event().
 */ 1 4 this 3 283  
11 0 0 7 102 293 0 0 92 /**
 * Returns the list of recently-generated ButtonEvents.
 * The list is also cleared.
 */ 1 4 this 3 285  
12 0 0 6 103 258 0 0 198 /**
 * Returns true if this device has a pending pointer event (a mouse movement),
 * or false otherwise.  If this returns true, the particular event may be
 * extracted via get_pointer_event().
 */ 1 4 this 3 283  
13 0 0 7 104 295 0 0 99 /**
 * Returns a PointerEventList containing all the recent pointer events.
 * Clears the list.
 */ 1 4 this 3 285  
14 0 0 4 105 289 0 0 58 /**
 * Writes a one-line string describing the device.
 */ 2 4 this 3 283  3 out 1 296  
15 0 0 7 121 299 0 0 0 0 
16 0 0 6 83 258 0 0 115 /**
 * Returns true if the device features a tracker that can track position and/or
 * orientation in 3D space.
 */ 1 4 this 3 283  
17 0 0 6 86 258 0 0 99 /**
 * Returns true if the device may be able to provide information about its
 * battery life.
 */ 1 4 this 3 283  
18 0 0 6 87 286 0 0 279 /**
 * Returns the number of buttons known to the device.  This includes those
 * buttons whose state has been seen, as well as buttons that have been
 * associated with a ButtonHandle even if their state is unknown.  This number
 * may change as more buttons are discovered.
 */ 1 4 this 3 283  
19 0 0 6 90 286 0 0 126 /**
 * Returns the number of analog axes known to the InputDevice.  This number
 * may change as more axes are discovered.
 */ 1 4 this 3 283  
20 0 0 7 38 290 119 0 0 1 6 param0 0 300  
21 0 0 6 29 258 0 0 0 1 4 this 3 290  
22 0 0 7 51 291 128 0 0 1 6 param0 0 302  
23 0 0 6 41 258 0 0 0 1 4 this 3 291  
24 0 0 7 61 304 134 0 0 0 
25 0 0 7 61 304 134 0 0 1 6 param0 0 305  
26 0 0 6 123 258 0 0 314 /**
 * Forks a separate thread to do all the polling of connected devices.  The
 * forked thread will poll after every poll_time seconds has elapsed.  Returns
 * true if the fork was successful, or false otherwise (for instance, because
 * we were already forked, or because asynchronous threads are disabled).
 */ 2 4 this 3 307  9 poll_time 1 244  
27 0 0 6 124 258 0 0 130 /**
 * Returns true if the ClientBase has been forked (and, therefore, poll() does
 * not need to be called), false otherwise.
 */ 1 4 this 3 308  
28 0 0 6 125 258 0 0 183 /**
 * Initiates a poll of the client devices, if we are not forked and if we have
 * not already polled this frame.  Returns true if the poll occurred, or false
 * if it did not.
 */ 1 4 this 3 307  
29 0 0 6 126 244 0 0 118 /**
 * Returns the time (according to the global ClockObject's get_real_time()
 * method) of the last device poll.
 */ 1 4 this 3 308  
30 0 0 4 127 289 0 0 138 /**
 * Specifies the coordinate system that all devices associated with this
 * client will operate in.  Normally, this is CS_default.
 */ 2 4 this 3 307  2 cs 1 310  
31 0 0 6 128 310 0 0 136 /**
 * Returns the coordinate system that all devices associated with this client
 * will operate in.  Normally, this is CS_default.
 */ 1 4 this 3 308  
32 0 0 7 129 299 0 0 0 0 
33 0 0 7 132 313 0 0 0 1 6 param0 0 311  
34 0 0 7 132 313 0 0 10 /**
 *
 */ 2 6 client 1 307  11 device_name 1 314  
35 0 0 7 132 313 0 0 10 /**
 *
 */ 1 6 device 1 285  
36 0 0 6 133 258 0 0 97 /**
 * Returns true if the AnalogNode is valid and connected to a server, false
 * otherwise.
 */ 1 4 this 3 311  
37 0 0 6 134 315 0 0 133 /**
 * Returns the number of analog controls known to the AnalogNode.  This number
 * may change as more controls are discovered.
 */ 1 4 this 3 311  
38 0 0 6 135 244 0 0 193 /**
 * Returns the current position of indicated analog control identified by its
 * index number, or 0.0 if the control is unknown.  The normal range of a
 * single control is -1.0 to 1.0.
 */ 2 4 this 3 311  5 index 1 315  
39 0 0 6 136 258 0 0 153 /**
 * Returns true if the state of the indicated analog control is known, or
 * false if we have never heard anything about this particular control.
 */ 2 4 this 3 311  5 index 1 315  
40 0 0 4 137 289 0 0 314 /**
 * Causes a particular analog control to be placed in the data graph for the
 * indicated channel.  Normally, a mouse uses channels 0 and 1 for the X and Y
 * information, respectively; channels 0, 1, and 2 are available.  If flip is
 * true, the analog control value will be reversed before outputting it.
 */ 4 4 this 3 313  7 channel 1 315  5 index 1 315  4 flip 1 258  
41 0 0 4 138 289 0 0 107 /**
 * Removes the output to the data graph associated with the indicated channel.
 * See set_output().
 */ 2 4 this 3 313  7 channel 1 315  
42 0 0 6 139 315 0 0 174 /**
 * Returns the analog control index that is output to the data graph on the
 * indicated channel, or -1 if no control is output on that channel.  See
 * set_output().
 */ 2 4 this 3 311  7 channel 1 315  
43 0 0 6 140 258 0 0 143 /**
 * Returns true if the analog control index that is output to the data graph
 * on the indicated channel is flipped.  See set_output().
 */ 2 4 this 3 311  7 channel 1 315  
44 0 0 7 141 299 0 0 0 0 
45 0 0 7 143 318 0 0 0 1 6 param0 0 316  
46 0 0 7 143 318 0 0 10 /**
 *
 */ 2 6 client 1 307  11 device_name 1 314  
47 0 0 7 143 318 0 0 10 /**
 *
 */ 1 6 device 1 285  
48 0 0 6 144 258 0 0 97 /**
 * Returns true if the ButtonNode is valid and connected to a server, false
 * otherwise.
 */ 1 4 this 3 316  
49 0 0 6 145 315 0 0 283 /**
 * Returns the number of buttons known to the ButtonNode.  This includes those
 * buttons whose state has been seen, as well as buttons that have been
 * associated with a ButtonHandle even if their state is unknown.  This number
 * may change as more buttons are discovered.
 */ 1 4 this 3 316  
50 0 0 4 146 289 0 0 490 /**
 * Associates the indicated ButtonHandle with the button of the indicated
 * index number.  When the given button index changes state, a corresponding
 * ButtonEvent will be generated with the given ButtonHandle.  Pass
 * ButtonHandle::none() to turn off any association.
 *
 * It is not necessary to call this if you simply want to query the state of
 * the various buttons by index number; this is only necessary in order to
 * generate ButtonEvents when the buttons change state.
 */ 3 4 this 3 318  5 index 1 315  6 button 1 288  
51 0 0 7 147 288 0 0 184 /**
 * Returns the ButtonHandle that was previously associated with the given
 * index number by a call to set_button_map(), or ButtonHandle::none() if no
 * button was associated.
 */ 2 4 this 3 316  5 index 1 315  
52 0 0 6 148 258 0 0 147 /**
 * Returns true if the indicated button (identified by its index number) is
 * currently known to be down, or false if it is up or unknown.
 */ 2 4 this 3 316  5 index 1 315  
53 0 0 6 149 258 0 0 144 /**
 * Returns true if the state of the indicated button is known, or false if we
 * have never heard anything about this particular button.
 */ 2 4 this 3 316  5 index 1 315  
54 0 0 7 150 299 0 0 0 0 
55 0 0 7 152 319 0 0 10 /**
 *
 */ 2 6 client 1 307  11 device_name 1 314  
56 0 0 7 152 319 0 0 0 1 6 param0 0 320  
57 0 0 6 153 258 0 0 95 /**
 * Returns true if the DialNode is valid and connected to a server, false
 * otherwise.
 */ 1 4 this 3 320  
58 0 0 6 154 315 0 0 123 /**
 * Returns the number of dial dials known to the DialNode.  This number may
 * change as more dials are discovered.
 */ 1 4 this 3 320  
59 0 0 6 155 244 0 0 216 /**
 * Returns the number of complete revolutions of the dial since the last time
 * read_dial() was called.  This is a destructive operation; it is not
 * possible to read the dial without resetting the counter.
 */ 2 4 this 3 319  5 index 1 315  
60 0 0 6 156 258 0 0 145 /**
 * Returns true if the state of the indicated dial dial is known, or false if
 * we have never heard anything about this particular dial.
 */ 2 4 this 3 320  5 index 1 315  
61 0 0 7 157 299 0 0 0 0 
62 0 0 7 159 322 203 0 10 /**
 *
 */ 0 
63 0 0 7 159 322 203 0 10 /**
 *
 */ 1 4 copy 1 323  
64 0 0 6 160 322 0 0 0 2 4 this 3 322  4 copy 1 323  
65 0 0 4 162 289 0 0 56 /**
 * Removes all InputDevices from the collection.
 */ 1 4 this 3 322  
66 0 0 4 163 289 0 0 160 /**
 * This is a hint to Panda to allocate enough memory to hold the given number
 * of InputDevices, if you know ahead of time how many you will be adding.
 */ 2 4 this 3 322  3 num 1 286  
67 0 0 7 164 285 0 0 57 /**
 * Returns the nth InputDevice in the collection.
 */ 2 4 this 3 323  5 index 1 286  
68 0 0 6 165 286 0 0 59 /**
 * Returns the number of devices in the collection.
 */ 1 4 this 3 323  
69 0 0 4 166 289 0 0 103 /**
 * Writes a brief one-line description of the InputDeviceSet to the indicated
 * output stream.
 */ 2 4 this 3 323  3 out 1 296  
70 0 0 4 167 289 0 0 108 /**
 * Writes a complete multi-line description of the InputDeviceSet to the
 * indicated output stream.
 */ 3 4 this 3 323  3 out 1 296  12 indent_level 1 315  
71 0 0 7 169 322 203 0 64 /**
 * Description: Returns all currently connected devices.
 */ 1 4 this 3 325  
72 0 0 7 169 322 203 0 90 /**
 * Description: Returns all currently connected devices of the given device class.
 */ 2 4 this 3 325  12 device_class 1 253  
73 0 0 4 170 289 0 0 166 /**
 * Called when a new device has been discovered.  This may also be used to
 * register virtual devices.
 *
 * This causes a connect-device event to be thrown.
 */ 2 4 this 3 327  6 device 1 285  
74 0 0 4 171 289 0 0 166 /**
 * Called when a device has been removed, or when a device should otherwise no
 * longer be tracked.
 *
 * This causes a disconnect-device event to be thrown.
 */ 2 4 this 3 327  6 device 1 285  
75 0 0 4 172 289 0 0 109 /**
 * Polls the system to see if there are any new devices.  In some
 * implementations this is a no-op.
 */ 1 4 this 3 327  
76 0 0 6 173 327 0 0 61 /**
 * Returns the singleton InputDeviceManager instance.
 */ 0 
77 0 0 7 175 328 219 0 0 2 6 device 1 285  4 name 1 314  
78 0 0 7 175 328 219 0 0 1 6 param0 0 329  
79 0 0 7 180 299 0 0 0 0 
80 0 0 7 183 333 0 0 85 /**
 * Creates a new device using the Linux joystick device with the given index.
 */ 2 7 manager 1 331  5 index 1 286  
81 0 0 6 184 258 0 0 52 /**
 * Returns true if there are pending events.
 */ 1 4 this 3 334  
82 0 0 7 185 299 0 0 0 0 
83 0 0 7 187 336 0 0 10 /**
 *
 */ 2 6 client 1 307  11 device_name 1 314  
84 0 0 7 187 336 0 0 10 /**
 *
 */ 1 6 device 1 285  
85 0 0 7 187 336 0 0 0 1 6 param0 0 337  
86 0 0 6 188 258 0 0 98 /**
 * Returns true if the TrackerNode is valid and connected to a server, false
 * otherwise.
 */ 1 4 this 3 337  
87 0 0 6 189 339 0 0 75 /**
 * Returns the current position of the tracker, if it is available.
 */ 1 4 this 3 337  
88 0 0 6 190 340 0 0 78 /**
 * Returns the current orientation of the tracker, if it is available.
 */ 1 4 this 3 337  
89 0 0 6 191 341 0 0 96 /**
 * Returns the current position and orientation of the tracker, as a combined
 * matrix.
 */ 1 4 this 3 337  
90 0 0 6 192 244 0 0 57 /**
 * Returns the time of the tracker's last update.
 */ 1 4 this 3 337  
91 0 0 6 193 258 0 0 51 /**
 * True if this data comes with timestamps.
 */ 1 4 this 3 337  
92 0 0 4 194 289 0 0 257 /**
 * Specifies the coordinate system that the tracker associated with this node
 * will operate in.  Normally, this is set from the ClientBase that's used to
 * create the TrackerNode, so it should not need to be set on an individual
 * tracker basis.
 */ 2 4 this 3 336  2 cs 1 310  
93 0 0 6 195 310 0 0 103 /**
 * Returns the coordinate system that the tracker associated with this node
 * will operate in.
 */ 1 4 this 3 337  
94 0 0 4 196 289 0 0 165 /**
 * Specifies the coordinate system that the TrackerNode will convert its
 * transform into for passing down the data graph.  Normally, this is
 * CS_default.
 */ 2 4 this 3 336  2 cs 1 310  
95 0 0 6 197 310 0 0 163 /**
 * Returns the coordinate system that the TrackerNode will convert its
 * transform into for passing down the data graph.  Normally, this is
 * CS_default.
 */ 1 4 this 3 337  
96 0 0 7 198 299 0 0 0 0 
97 0 0 7 200 347 242 0 0 1 6 param0 0 345  
98 0 0 7 200 347 242 0 10 /**
 *
 */ 1 4 name 1 314  
99 0 0 4 201 289 0 0 155 /**
 * Sets the current mouse pixel location, where (0,0) is the upper left, and
 * (width-1, height-1) is the lower right pixel of the virtual window.
 */ 3 4 this 3 347  1 x 1 315  1 y 1 315  
100 0 0 4 202 289 0 0 136 /**
 * Sets the size of the "window" in which the mouse rolls.  This changes the
 * meaning of the values passed to set_mouse_pos().
 */ 3 4 this 3 347  5 width 1 315  6 height 1 315  
101 0 0 4 203 289 0 0 217 /**
 * Sets whether the mouse should appear to be within the window or not.  If
 * this is true, the mouse is within the window; if false, the mouse is not
 * within the window (and set_mouse_pos() means nothing).
 */ 2 4 this 3 347  4 flag 1 258  
102 0 0 4 204 289 0 0 167 /**
 * Simulates a mouse or keyboard button being depressed.  This should be
 * followed up by a call to release_button() sometime later (possibly
 * immediately).
 */ 2 4 this 3 347  6 button 1 288  
103 0 0 4 205 289 0 0 105 /**
 * Simulates the button being released.  This should follow a previous call to
 * press_button().
 */ 2 4 this 3 347  6 button 1 288  
104 0 0 7 206 299 0 0 0 0 
105
243 11 TrackerData 0 141313 11 TrackerData 11 TrackerData 0 0 0 0 113 4 348 349 350 351 0 0 0 0 0 0 64
/**
 * Stores the kinds of data that a tracker might output.
 */

244 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

245 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 246 0 0 0 0 0 0 0 0 0 0

246 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 247 0 0 0 0 0 0 0 0 0 0

247 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

248 18 LOrientation const 0 8832 18 LOrientation const 18 LOrientation const 0 0 249 0 0 0 0 0 0 0 0 0 0

249 12 LOrientation 0 2105344 12 LOrientation 12 LOrientation 0 0 250 0 0 0 0 0 0 0 0 0 0

250 13 LOrientationf 0 2048 13 LOrientationf 13 LOrientationf 0 0 0 0 0 0 0 0 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

251 11 InputDevice 0 75777 11 InputDevice 11 InputDevice 0 0 0 0 0 16 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 15 142 151 152 153 154 155 156 157 158 159 160 161 162 163 169 0 0 1 0 252 0 0 0 9 253 254 255 256 257 260 261 266 268 959
/**
 * This is a structure representing a single input device.  Input devices may
 * have zero or more buttons, pointers, or axes associated with them, and
 * optionally a motion tracker.
 *
 * These devices are brought under a common interface because there is such a
 * large range of devices out there that may support any number of these types
 * of axes, we couldn't even begin to cover them with type-specific
 * subclasses.
 *
 * Use the various has_() and get_num_() methods to determine information about
 * the device capabilities. For instance, has_keyboard() will give an
 * indication that you can receive keystroke events from this device, and
 * get_num_buttons() will tell you that the device may send button events.
 *
 * There is the DeviceType enumeration, however, which will (if known) contain
 * identification of the general category of devices this fits in, such as
 * keyboard, mouse, gamepad, or flight stick.
 *
 * @since 1.10.0
 */

252 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

253 11 DeviceClass 0 9183232 24 InputDevice::DeviceClass 24 InputDevice::DeviceClass 251 0 0 0 0 0 0 0 0 0 11 7 unknown 20 InputDevice::unknown 47
// It is not known what type of device this is.
0 14 virtual_device 27 InputDevice::virtual_device 121
// This means that the device doesn't correspond to a physical
// device, but rather to a dynamic source of input events.
1 8 keyboard 21 InputDevice::keyboard 37
// A physical, alphabetical keyboard.
2 5 mouse 18 InputDevice::mouse 0
3 5 touch 18 InputDevice::touch 0
4 7 gamepad 20 InputDevice::gamepad 59
// A gamepad with action buttons, a D-pad, and thumbsticks.
5 12 flight_stick 25 InputDevice::flight_stick 0
6 14 steering_wheel 27 InputDevice::steering_wheel 0
7 9 dance_pad 22 InputDevice::dance_pad 0
8 3 hmd 16 InputDevice::hmd 24
// Head-mounted display.
9 13 spatial_mouse 26 InputDevice::spatial_mouse 45
// 3D mouse, such as produced by 3Dconnexion.
10 0 91
// This enum contains information that can be used to identify the
// type of input device.

254 7 Feature 0 9183232 20 InputDevice::Feature 20 InputDevice::Feature 251 0 0 0 0 0 0 0 0 0 5 7 pointer 20 InputDevice::pointer 51
// The device provides absolute screen coordinates.
0 8 keyboard 21 InputDevice::keyboard 56
// The device has an interface for providing text input.
1 7 tracker 20 InputDevice::tracker 51
// The device has a motion tracker, such as an HMD.
2 9 vibration 22 InputDevice::vibration 41
// The device can produce force feedback.
3 7 battery 20 InputDevice::battery 54
// The device provides information about battery life.
4 0 0

255 4 Axis 0 9183232 17 InputDevice::Axis 17 InputDevice::Axis 251 0 0 0 0 0 0 0 0 0 18 4 none 17 InputDevice::none 0
0 1 x 14 InputDevice::x 29
// Generic translational axes
1 1 y 14 InputDevice::y 0
2 1 z 14 InputDevice::z 0
3 3 yaw 16 InputDevice::yaw 57
// Generic rotational axes, used by joysticks and 3D mice
4 5 pitch 18 InputDevice::pitch 0
5 4 roll 17 InputDevice::roll 0
6 6 left_x 19 InputDevice::left_x 10
// Gamepad
7 6 left_y 19 InputDevice::left_y 0
8 12 left_trigger 25 InputDevice::left_trigger 0
9 7 right_x 20 InputDevice::right_x 0
10 7 right_y 20 InputDevice::right_y 0
11 13 right_trigger 26 InputDevice::right_trigger 0
12 8 throttle 21 InputDevice::throttle 24
// Flight stick specific
13 6 rudder 19 InputDevice::rudder 37
// When available separately from yaw
14 5 wheel 18 InputDevice::wheel 26
// Steering wheel / pedals
15 11 accelerator 24 InputDevice::accelerator 0
16 5 brake 18 InputDevice::brake 0
17 0 0

256 5 State 0 794624 18 InputDevice::State 18 InputDevice::State 251 0 0 0 0 0 0 0 0 0 3 9 S_unknown 22 InputDevice::S_unknown 0
0 4 S_up 17 InputDevice::S_up 0
1 6 S_down 19 InputDevice::S_down 0
2 0 0

257 11 ButtonState 0 403457 24 InputDevice::ButtonState 24 InputDevice::ButtonState 251 0 0 1 118 119 3 352 353 354 0 0 1 114 0 0 0 0

258 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

259 12 ButtonHandle 0 16779264 12 ButtonHandle 12 ButtonHandle 0 0 0 0 0 0 0 0 0 0 0 0 162
/**
 * A ButtonHandle represents a single button from any device, including
 * keyboard buttons and mouse buttons (but see KeyboardButton and
 * MouseButton).
 */

260 9 AxisState 0 403457 22 InputDevice::AxisState 22 InputDevice::AxisState 251 0 0 1 127 128 3 355 356 357 0 0 1 120 0 0 0 0

261 11 BatteryData 0 403457 24 InputDevice::BatteryData 24 InputDevice::BatteryData 251 0 0 1 133 134 2 358 359 0 0 0 0 0 0 0

262 9 short int 0 8258 9 short int 9 short int 0 1 0 0 0 0 0 0 0 0 0 0 0

263 6 string 0 2105344 11 std::string 11 std::string 0 0 264 0 0 0 0 0 0 0 0 0 0

264 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

265 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0

266 7 Buttons 0 2367488 20 InputDevice::Buttons 20 InputDevice::Buttons 251 0 267 0 0 0 0 0 0 0 0 0 0

267 22 pvector< ButtonState > 0 2048 35 pvector< InputDevice::ButtonState > 35 pvector< InputDevice::ButtonState > 0 0 0 0 0 0 0 0 0 0 0 0 0

268 4 Axes 0 2367488 17 InputDevice::Axes 17 InputDevice::Axes 251 0 269 0 0 0 0 0 0 0 0 0 0

269 20 pvector< AxisState > 0 2048 33 pvector< InputDevice::AxisState > 33 pvector< InputDevice::AxisState > 0 0 0 0 0 0 0 0 0 0 0 0 0

270 11 PointerData 0 2048 11 PointerData 11 PointerData 0 0 0 0 0 0 0 0 0 0 0 0 124
/**
 * Holds the data that might be generated by a 2-d pointer input device, such
 * as the mouse in the GraphicsWindow.
 */

271 10 ClientBase 0 75777 10 ClientBase 10 ClientBase 0 0 0 0 0 0 7 170 171 172 173 174 175 176 0 0 1 0 252 0 0 0 0 307
/**
 * An abstract base class for a family of client device interfaces--including
 * trackers, buttons, dials, and other analog inputs.
 *
 * This provides a common interface to connect to such devices and extract
 * their data; it is used by TrackerNode etc.  to put these devices in the
 * data graph.
 */

272 10 AnalogNode 0 75777 10 AnalogNode 10 AnalogNode 0 0 0 1 177 0 0 9 178 179 180 181 182 183 184 185 186 0 0 1 0 273 0 0 0 0 712
/**
 * This is the primary interface to analog controls like sliders and joysticks
 * associated with a ClientBase.  This creates a node that connects to the
 * named analog device, if it exists, and provides hooks to the user to read
 * the state of any of the sequentially numbered controls associated with that
 * device.
 *
 * Each control can return a value ranging from -1 to 1, reflecting the
 * current position of the control within its total range of motion.
 *
 * The user may choose up to two analog controls to place on the data graph as
 * the two channels of an xy datagram, similarly to the way a mouse places its
 * position data.  In this way, an AnalogNode may be used in place of a mouse.
 */

273 8 DataNode 0 2048 8 DataNode 8 DataNode 0 0 0 0 0 0 0 0 0 0 0 0 422
/**
 * The fundamental type of node for the data graph.  The DataNode class is
 * itself primarily intended as an abstract class; it defines no inputs and no
 * outputs.  Most kinds of data nodes will derive from this to specify the
 * inputs and outputs in the constructor.
 *
 * DataNode does not attempt to cycle its data with a PipelineCycler.  The
 * data graph is intended to be used only within a single thread.
 */

274 10 ButtonNode 0 75777 10 ButtonNode 10 ButtonNode 0 0 0 1 187 0 0 7 188 189 190 191 192 193 194 0 0 1 0 273 0 0 0 0 527
/**
 * This is the primary interface to on/off button devices associated with a
 * ClientBase.  This creates a node that connects to the named button device,
 * if it exists, and provides hooks to the user to read the state of any of
 * the sequentially numbered buttons associated with that device.
 *
 * It also can associate an arbitrary ButtonHandle with each button; when
 * buttons are associated with ButtonHandles, this node will put appropriate
 * up and down events on the data graph for each button state change.
 */

275 8 DialNode 0 75777 8 DialNode 8 DialNode 0 0 0 1 195 0 0 5 196 197 198 199 200 0 0 1 0 273 0 0 0 0 511
/**
 * This is the primary interface to infinite dial type devices associated with
 * a ClientBase.  This creates a node that connects to the named dial device,
 * if it exists, and provides hooks to the user to read the state of any of
 * the sequentially numbered dial controls associated with that device.
 *
 * A dial is a rotating device that does not have stops--it can keep rotating
 * any number of times.  Therefore it does not have a specific position at any
 * given time, unlike an AnalogDevice.
 */

276 14 InputDeviceSet 0 26625 14 InputDeviceSet 14 InputDeviceSet 0 0 0 1 201 203 0 7 202 204 205 206 207 208 209 0 0 0 0 0 192
/**
 * Manages a list of InputDevice objects, as returned by various
 * InputDeviceManager methods.  This is implemented like a set, meaning the
 * same device cannot occur more than once.
 */

277 18 InputDeviceManager 0 43009 18 InputDeviceManager 18 InputDeviceManager 0 0 0 0 0 0 5 210 211 212 213 214 0 0 0 0 0 145
/**
 * This class keeps track of all the devices on a system, and sends out events
 * when a device has been hot-plugged.
 *
 * @since 1.10.0
 */

278 15 InputDeviceNode 0 141313 15 InputDeviceNode 15 InputDeviceNode 0 0 0 1 215 219 1 376 1 218 0 0 1 0 273 0 0 0 0 175
/**
 * Reads the controller data sent from the InputDeviceManager, and transmits
 * it down the data graph.
 *
 * This is intended to only be accessed from the app thread.
 */

279 24 PointerTo< InputDevice > 0 2048 24 PointerTo< InputDevice > 24 PointerTo< InputDevice > 0 0 0 0 0 0 0 0 0 0 0 0 0

280 19 LinuxJoystickDevice 0 75777 19 LinuxJoystickDevice 19 LinuxJoystickDevice 0 0 0 1 220 0 0 2 221 222 0 0 1 0 251 0 0 0 0 134
/**
 * This is a type of device that uses the Linux /dev/input/js# API to read
 * data from a game controller.
 *
 * @since 1.10.0
 */

281 11 TrackerNode 0 75777 11 TrackerNode 11 TrackerNode 0 0 0 1 223 0 0 11 224 225 226 227 228 229 230 231 232 233 234 0 0 1 0 273 0 0 0 0 244
/**
 * This class reads the position and orientation information from a tracker
 * device and makes it available as a transformation on the data graph.
 * It is also the primary interface to a Tracker object associated with a
 * ClientBase.
 */

282 12 VirtualMouse 0 141313 12 VirtualMouse 12 VirtualMouse 0 0 0 1 235 242 0 6 236 237 238 239 240 241 0 0 1 0 273 0 0 0 0 291
/**
 * Poses as a MouseAndKeyboard object in the datagraph, but accepts input from
 * user calls, rather than reading the actual mouse and keyboard from an input
 * device.  The user can write high-level code to put the mouse wherever
 * he/she wants, and to insert keypresses on demand.
 */

283 19 InputDevice const * 0 8576 19 InputDevice const * 19 InputDevice const * 0 0 284 0 0 0 0 0 0 0 0 0 0

284 17 InputDevice const 0 8832 17 InputDevice const 17 InputDevice const 0 0 251 0 0 0 0 0 0 0 0 0 0

285 13 InputDevice * 0 8576 13 InputDevice * 13 InputDevice * 0 0 251 0 0 0 0 0 0 0 0 0 0

286 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 287 0 0 0 0 0 0 0 0 0 0

287 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

288 14 ButtonHandle * 0 8576 14 ButtonHandle * 14 ButtonHandle * 0 0 259 0 0 0 0 0 0 0 0 0 0

289 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

290 13 ButtonState * 0 8576 26 InputDevice::ButtonState * 26 InputDevice::ButtonState * 0 0 257 0 0 0 0 0 0 0 0 0 0

291 11 AxisState * 0 8576 24 InputDevice::AxisState * 24 InputDevice::AxisState * 0 0 260 0 0 0 0 0 0 0 0 0 0

292 15 ButtonEventList 0 2048 15 ButtonEventList 15 ButtonEventList 0 0 0 0 0 0 0 0 0 0 0 0 225
/**
 * Records a set of button events that happened recently.  This class is
 * usually used only in the data graph, to transmit the recent button presses,
 * but it may be used anywhere a list of ButtonEvents is desired.
 */

293 17 ButtonEventList * 0 8576 17 ButtonEventList * 17 ButtonEventList * 0 0 292 0 0 0 0 0 0 0 0 0 0

294 16 PointerEventList 0 2048 16 PointerEventList 16 PointerEventList 0 0 0 0 0 0 0 0 0 0 0 0 228
/**
 * Records a set of pointer events that happened recently.  This class is
 * usually used only in the data graph, to transmit the recent pointer
 * presses, but it may be used anywhere a list of PointerEvents is desired.
 */

295 18 PointerEventList * 0 8576 18 PointerEventList * 18 PointerEventList * 0 0 294 0 0 0 0 0 0 0 0 0 0

296 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 297 0 0 0 0 0 0 0 0 0 0

297 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

298 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

299 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 298 0 0 0 0 0 0 0 0 0 0

300 19 ButtonState const * 0 8576 32 InputDevice::ButtonState const * 32 InputDevice::ButtonState const * 0 0 301 0 0 0 0 0 0 0 0 0 0

301 17 ButtonState const 0 8832 30 InputDevice::ButtonState const 30 InputDevice::ButtonState const 0 0 257 0 0 0 0 0 0 0 0 0 0

302 17 AxisState const * 0 8576 30 InputDevice::AxisState const * 30 InputDevice::AxisState const * 0 0 303 0 0 0 0 0 0 0 0 0 0

303 15 AxisState const 0 8832 28 InputDevice::AxisState const 28 InputDevice::AxisState const 0 0 260 0 0 0 0 0 0 0 0 0 0

304 13 BatteryData * 0 8576 26 InputDevice::BatteryData * 26 InputDevice::BatteryData * 0 0 261 0 0 0 0 0 0 0 0 0 0

305 19 BatteryData const * 0 8576 32 InputDevice::BatteryData const * 32 InputDevice::BatteryData const * 0 0 306 0 0 0 0 0 0 0 0 0 0

306 17 BatteryData const 0 8832 30 InputDevice::BatteryData const 30 InputDevice::BatteryData const 0 0 261 0 0 0 0 0 0 0 0 0 0

307 12 ClientBase * 0 8576 12 ClientBase * 12 ClientBase * 0 0 271 0 0 0 0 0 0 0 0 0 0

308 18 ClientBase const * 0 8576 18 ClientBase const * 18 ClientBase const * 0 0 309 0 0 0 0 0 0 0 0 0 0

309 16 ClientBase const 0 8832 16 ClientBase const 16 ClientBase const 0 0 271 0 0 0 0 0 0 0 0 0 0

310 16 CoordinateSystem 0 532480 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 21
// Z-Up, Right-handed
1 12 CS_yup_right 12 CS_yup_right 21
// Y-Up, Right-handed
2 11 CS_zup_left 11 CS_zup_left 20
// Z-Up, Left-handed
3 11 CS_yup_left 11 CS_yup_left 20
// Y-Up, Left-handed
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

311 18 AnalogNode const * 0 8576 18 AnalogNode const * 18 AnalogNode const * 0 0 312 0 0 0 0 0 0 0 0 0 0

312 16 AnalogNode const 0 8832 16 AnalogNode const 16 AnalogNode const 0 0 272 0 0 0 0 0 0 0 0 0 0

313 12 AnalogNode * 0 8576 12 AnalogNode * 12 AnalogNode * 0 0 272 0 0 0 0 0 0 0 0 0 0

314 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

315 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

316 18 ButtonNode const * 0 8576 18 ButtonNode const * 18 ButtonNode const * 0 0 317 0 0 0 0 0 0 0 0 0 0

317 16 ButtonNode const 0 8832 16 ButtonNode const 16 ButtonNode const 0 0 274 0 0 0 0 0 0 0 0 0 0

318 12 ButtonNode * 0 8576 12 ButtonNode * 12 ButtonNode * 0 0 274 0 0 0 0 0 0 0 0 0 0

319 10 DialNode * 0 8576 10 DialNode * 10 DialNode * 0 0 275 0 0 0 0 0 0 0 0 0 0

320 16 DialNode const * 0 8576 16 DialNode const * 16 DialNode const * 0 0 321 0 0 0 0 0 0 0 0 0 0

321 14 DialNode const 0 8832 14 DialNode const 14 DialNode const 0 0 275 0 0 0 0 0 0 0 0 0 0

322 16 InputDeviceSet * 0 8576 16 InputDeviceSet * 16 InputDeviceSet * 0 0 276 0 0 0 0 0 0 0 0 0 0

323 22 InputDeviceSet const * 0 8576 22 InputDeviceSet const * 22 InputDeviceSet const * 0 0 324 0 0 0 0 0 0 0 0 0 0

324 20 InputDeviceSet const 0 8832 20 InputDeviceSet const 20 InputDeviceSet const 0 0 276 0 0 0 0 0 0 0 0 0 0

325 26 InputDeviceManager const * 0 8576 26 InputDeviceManager const * 26 InputDeviceManager const * 0 0 326 0 0 0 0 0 0 0 0 0 0

326 24 InputDeviceManager const 0 8832 24 InputDeviceManager const 24 InputDeviceManager const 0 0 277 0 0 0 0 0 0 0 0 0 0

327 20 InputDeviceManager * 0 8576 20 InputDeviceManager * 20 InputDeviceManager * 0 0 277 0 0 0 0 0 0 0 0 0 0

328 17 InputDeviceNode * 0 8576 17 InputDeviceNode * 17 InputDeviceNode * 0 0 278 0 0 0 0 0 0 0 0 0 0

329 23 InputDeviceNode const * 0 8576 23 InputDeviceNode const * 23 InputDeviceNode const * 0 0 330 0 0 0 0 0 0 0 0 0 0

330 21 InputDeviceNode const 0 8832 21 InputDeviceNode const 21 InputDeviceNode const 0 0 278 0 0 0 0 0 0 0 0 0 0

331 25 LinuxInputDeviceManager * 0 8576 25 LinuxInputDeviceManager * 25 LinuxInputDeviceManager * 0 0 332 0 0 0 0 0 0 0 0 0 0

332 23 LinuxInputDeviceManager 0 17827840 23 LinuxInputDeviceManager 23 LinuxInputDeviceManager 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This class keeps track of all the devices on a system, and sends out events
 * when a device has been hot-plugged.
 */

333 21 LinuxJoystickDevice * 0 8576 21 LinuxJoystickDevice * 21 LinuxJoystickDevice * 0 0 280 0 0 0 0 0 0 0 0 0 0

334 27 LinuxJoystickDevice const * 0 8576 27 LinuxJoystickDevice const * 27 LinuxJoystickDevice const * 0 0 335 0 0 0 0 0 0 0 0 0 0

335 25 LinuxJoystickDevice const 0 8832 25 LinuxJoystickDevice const 25 LinuxJoystickDevice const 0 0 280 0 0 0 0 0 0 0 0 0 0

336 13 TrackerNode * 0 8576 13 TrackerNode * 13 TrackerNode * 0 0 281 0 0 0 0 0 0 0 0 0 0

337 19 TrackerNode const * 0 8576 19 TrackerNode const * 19 TrackerNode const * 0 0 338 0 0 0 0 0 0 0 0 0 0

338 17 TrackerNode const 0 8832 17 TrackerNode const 17 TrackerNode const 0 0 281 0 0 0 0 0 0 0 0 0 0

339 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 245 0 0 0 0 0 0 0 0 0 0

340 20 LOrientation const * 0 8576 20 LOrientation const * 20 LOrientation const * 0 0 248 0 0 0 0 0 0 0 0 0 0

341 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 342 0 0 0 0 0 0 0 0 0 0

342 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 343 0 0 0 0 0 0 0 0 0 0

343 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 344 0 0 0 0 0 0 0 0 0 0

344 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

345 20 VirtualMouse const * 0 8576 20 VirtualMouse const * 20 VirtualMouse const * 0 0 346 0 0 0 0 0 0 0 0 0 0

346 18 VirtualMouse const 0 8832 18 VirtualMouse const 18 VirtualMouse const 0 0 282 0 0 0 0 0 0 0 0 0 0

347 14 VirtualMouse * 0 8576 14 VirtualMouse * 14 VirtualMouse * 0 0 282 0 0 0 0 0 0 0 0 0 0

0
29
348 4 time 0 6 244 105 106 0 0 0 0 0 0 17 TrackerData::time 0

349 3 pos 0 6 245 107 108 0 0 0 0 0 0 16 TrackerData::pos 0

350 6 orient 0 6 248 109 110 0 0 0 0 0 0 19 TrackerData::orient 0

351 2 dt 0 6 244 111 112 0 0 0 0 0 0 15 TrackerData::dt 0

352 5 known 0 2 258 115 0 0 0 0 0 0 0 31 InputDevice::ButtonState::known 0

353 7 pressed 0 2 258 116 0 0 0 0 0 0 0 33 InputDevice::ButtonState::pressed 0

354 6 handle 0 2 259 117 0 0 0 0 0 0 0 32 InputDevice::ButtonState::handle 0

355 4 axis 0 6 255 121 122 0 0 0 0 0 0 28 InputDevice::AxisState::axis 0

356 5 value 0 6 244 123 124 0 0 0 0 0 0 29 InputDevice::AxisState::value 0

357 5 known 0 6 258 125 126 0 0 0 0 0 0 29 InputDevice::AxisState::known 0

358 5 level 0 6 262 129 130 0 0 0 0 0 0 31 InputDevice::BatteryData::level 35
// Ranges from 0 through max_level.

359 9 max_level 0 6 262 131 132 0 0 0 0 0 0 35 InputDevice::BatteryData::max_level 34
// Maximum value of 'level' field.

360 4 name 0 2 263 135 0 0 0 0 0 0 0 17 InputDevice::name 48
// The human-readable name of this input device.

361 12 manufacturer 0 2 263 136 0 0 0 0 0 0 0 25 InputDevice::manufacturer 63
// The device's manufacturer, or the empty string if not known.

362 13 serial_number 0 2 263 137 0 0 0 0 0 0 0 26 InputDevice::serial_number 64
// The device's serial number, or the empty string if not known.

363 9 vendor_id 0 2 265 138 0 0 0 0 0 0 0 22 InputDevice::vendor_id 50
// USB vendor ID of the device, or 0 if not known.

364 10 product_id 0 2 265 139 0 0 0 0 0 0 0 23 InputDevice::product_id 51
// USB product ID of the device, or 0 if not known.

365 9 connected 0 2 258 140 0 0 0 0 0 0 0 22 InputDevice::connected 139
// This is false if we know that the device is not currently connected.
// May report false positives if we can't know this with certainty.

366 12 device_class 0 2 253 141 0 0 0 0 0 0 0 25 InputDevice::device_class 127
// This contains an identification of the general type of device.  If
// this could not be determined, it is set to DC_unknown.

367 7 tracker 0 10 243 143 0 144 0 0 0 0 0 20 InputDevice::tracker 48
// Getters for the various types of device data.

368 7 battery 0 10 261 145 0 146 0 0 0 0 0 20 InputDevice::battery 0

369 7 buttons 0 66 257 148 0 0 0 0 147 0 0 20 InputDevice::buttons 40
// Make device buttons and axes iterable

370 4 axes 0 66 260 150 0 0 0 0 149 0 0 17 InputDevice::axes 0

371 8 _buttons 0 2 266 164 0 0 0 0 0 0 0 21 InputDevice::_buttons 0

372 5 _axes 0 2 268 165 0 0 0 0 0 0 0 18 InputDevice::_axes 0

373 13 _pointer_data 0 2 270 166 0 0 0 0 0 0 0 26 InputDevice::_pointer_data 0

374 13 _battery_data 0 2 261 167 0 0 0 0 0 0 0 26 InputDevice::_battery_data 0

375 13 _tracker_data 0 2 243 168 0 0 0 0 0 0 0 26 InputDevice::_tracker_data 0

376 6 device 0 6 279 216 217 0 0 0 0 0 0 23 InputDeviceNode::device 0

0
